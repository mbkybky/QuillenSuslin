import QuillenSuslin.Horrocks
import QuillenSuslin.BivariatePolynomial
import QuillenSuslin.SuslinMonicPolynomialThm

open Module Polynomial Finset BigOperators Bivariate

variable {R : Type*} [CommRing R] [IsDomain R]
variable {s : Type*} [Fintype s] [DecidableEq s]

/-- Suppose $v(x) \sim v(0)$ over the localization $R_S[x]$. Then there exists a $c \in S$ such
  that $v(x) \sim v(x + cy)$ over $R[x, y]$. -/
theorem lem10 {S : Submonoid R} (hs : S ≤ nonZeroDivisors R) (v : s → R[X])
    (h : UnimodularVectorEquiv (fun i => (v i).map (algebraMap R (Localization S)))
      (fun i => C (algebraMap R (Localization S) ((v i).eval 0)))) :
    ∃ c : S, UnimodularVectorEquiv (fun i => C (v i))
      (fun i => (v i).eval₂ ((C : R[X] →+* R[X][Y]).comp C) (C X + (c : R) • Y)) := by
  rcases h with ⟨M, hM⟩
  let Sx : Submonoid R[X] := S.map (C : R →+* R[X])
  let Sxy : Submonoid R[X][Y] := Sx.map (C : R[X] →+* R[X][Y])
  let : IsLocalization Sx (Localization S)[X] := by
    simpa [Sx] using (Polynomial.isLocalization S (Localization S))
  let : IsLocalization Sxy ((Localization S)[X][Y]) := by
    simpa [Sxy] using (Polynomial.isLocalization Sx (Localization S)[X])
  rcases IsLocalization.exist_integer_multiples_of_finite Sxy (fun ij : s × s => W S M ij.1 ij.2)
    with ⟨b, hb⟩
  rcases b.property with ⟨rX, hrX, hrXb⟩
  rcases hrX with ⟨rR, hrR, hrRC⟩
  let c : S := ⟨rR, hrR⟩
  have hrXb : (C (C (c : R)) : R[X][Y]) = (b : R[X][Y]) :=
    (congrArg (C : R[X] →+* R[X][Y]) hrRC).trans <| by simpa [c] using hrXb
  have hb : ∀ ij : s × s, IsLocalization.IsInteger R[X][Y]
      ((C (C (c : R)) : R[X][Y]) • W S M ij.1 ij.2) := by
    intro ij
    simpa [hrXb, Algebra.smul_def] using hb ij
  have hc : ∀ i j : s,
      IsLocalization.IsInteger R[X][Y] ((C (C (c : R)) : R[X][Y]) • σA c (W S M i j)) := by
    intro i j
    have hfix : σA c (C (C ((algebraMap R (Localization S)) (c : R)))) =
        (C (C ((algebraMap R (Localization S)) (c : R)))) := by
      simp only [σA, algebraMap_smul, coe_eval₂RingHom, eval₂_C]
    simpa only [Algebra.smul_def, algebraMap_def, coe_mapRingHom, map_C, map_mul, hfix] using
      isInteger_σA c (hb (i, j))
  have hmulVec : ((U hs M hc)⁻¹.1).mulVec (fun i => C (v i)) = _ := hU hs v M hM hc
  exact ⟨c, (U hs M hc)⁻¹, by simpa only [Matrix.coe_units_inv] using hmulVec⟩

noncomputable section cor11

abbrev cor11ι : R →+* R[X][Y] := (C : R[X] →+* R[X][Y]).comp (C : R →+* R[X])

abbrev cor11vx (v : s → R[X]) : s → R[X][Y] := fun i => C (v i)

/-- The vector `v(x + qy)` in `R[X][Y]`. -/
abbrev cor11vxy (v : s → R[X]) (q : R) : s → R[X][Y] :=
  fun i => (v i).eval₂ cor11ι (C X + q • Y)

omit [IsDomain R] in
lemma cor11_hAlg : algebraMap R R[X][Y] = cor11ι := by
  ext r
  simp [cor11ι]

/-- Push a unimodular-vector equivalence along a ring homomorphism. -/
theorem unimodularVectorEquiv_map {A B : Type*} [CommRing A] [CommRing B] (f : A →+* B)
    {v w : s → A} (hvw : UnimodularVectorEquiv v w) :
    UnimodularVectorEquiv (fun i => f (v i)) (fun i => f (w i)) := by
  rcases hvw with ⟨M, hM⟩
  refine ⟨Matrix.GeneralLinearGroup.map f M, ?_⟩
  ext i
  have hi : (M.1.mulVec v) i = w i := congrArg (fun u : s → A => u i) hM
  have hi' : f ((M.1.mulVec v) i) = f (w i) := congrArg f hi
  have hmap : (M.1.map f).mulVec (fun j => f (v j)) i = f ((M.1.mulVec v) i) := by
    simpa [Function.comp] using (RingHom.map_mulVec f M.1 v i).symm
  simpa [Matrix.GeneralLinearGroup.map_apply, RingHom.mapMatrix_apply] using hmap.trans hi'

/-- The ideal generated by the coordinates of `M.mulVec v` agrees with the ideal generated by the
coordinates of `v` when `M ∈ GL`. (Ring-level version.) -/
theorem ideal_span_range_mulVec_ring {A : Type*} [CommRing A] (M : Matrix.GeneralLinearGroup s A)
    (v : s → A) : Ideal.span (Set.range (M.1.mulVec v)) = Ideal.span (Set.range v) := by
  -- First show `span (range (M.mulVec v)) ≤ span (range v)` for all `M`.
  have span_mulVec_le (N : Matrix.GeneralLinearGroup s A) (v : s → A) :
      Ideal.span (Set.range (N.1.mulVec v)) ≤ Ideal.span (Set.range v) := by
    let I : Ideal A := Ideal.span (Set.range v)
    refine Ideal.span_le.2 ?_
    rintro _ ⟨i, rfl⟩
    have hvj (j : s) : v j ∈ I := Ideal.subset_span ⟨j, rfl⟩
    have hterm (j : s) : N.1 i j * v j ∈ I := by
      simpa [mul_comm] using I.mul_mem_left (N.1 i j) (hvj j)
    simpa [Matrix.mulVec, dotProduct, I] using I.sum_mem (fun j _ => hterm j)
  refine le_antisymm (span_mulVec_le M v) ?_
  have hle' :
      Ideal.span (Set.range ((M⁻¹).1.mulVec (M.1.mulVec v))) ≤
        Ideal.span (Set.range (M.1.mulVec v)) :=
    span_mulVec_le (M⁻¹) (M.1.mulVec v)
  simpa using hle'

/-- `IsUnimodular` is invariant under `UnimodularVectorEquiv`. (Ring-level version.) -/
theorem isUnimodular_iff_of_unimodularVectorEquiv_ring {A : Type*} [CommRing A] {v w : s → A}
    (hvw : UnimodularVectorEquiv v w) : IsUnimodular v ↔ IsUnimodular w := by
  rcases hvw with ⟨M, rfl⟩
  unfold IsUnimodular
  simp [ideal_span_range_mulVec_ring (M := M) (v := v)]

/-- The ideal of `q : R` such that `v(x + qy) ∼ v(x)` in `R[X][Y]`. -/
def cor11IdealCarrier (v : s → R[X]) : Set R :=
  {q | UnimodularVectorEquiv (cor11vx v) (cor11vxy v q)}

omit [IsDomain R] in
/-- `0 ∈ cor11IdealCarrier v`. -/
lemma cor11Ideal_zero_mem (v : s → R[X]) : (0 : R) ∈ cor11IdealCarrier v := by
  have hC : (Polynomial.eval₂RingHom cor11ι (C X)) = (C : R[X] →+* R[X][Y]) := by
    refine Polynomial.ringHom_ext' ?_ ?_
    · ext r
      simp [cor11ι]
    · simp [cor11ι]
  have h0 : cor11vxy v 0 = cor11vx v := by
    funext i
    simpa [cor11vxy, cor11vx] using  congrArg (fun f : R[X] →+* R[X][Y] => f (v i)) hC
  simpa [cor11IdealCarrier, h0] using unimodularVectorEquiv_equivalence.refl (cor11vx v)

lemma cor11Ideal_add_mem (v : s → R[X]) {a b : R} (ha : a ∈ cor11IdealCarrier v)
    (hb : b ∈ cor11IdealCarrier v) :
    a + b ∈ cor11IdealCarrier v := by
  let shift : R[X][Y] →+* R[X][Y] := eval₂RingHom (Polynomial.eval₂RingHom cor11ι (C X + b • Y)) Y
  have hx : (fun i : s => shift (cor11vx v i)) = cor11vxy v b := by
    funext i
    dsimp [shift, cor11vx, cor11vxy]
    simp only [eval₂_C, coe_eval₂RingHom]
  have hxy : (fun i : s => shift (cor11vxy v a i)) = cor11vxy v (a + b) := by
    funext i
    have hcoeff : shift.comp cor11ι = cor11ι := by
      ext r
      dsimp [shift, cor11ι]
      simp only [eval₂_C, coe_eval₂RingHom, RingHom.coe_comp, Function.comp_apply]
    have hCX : shift (C X) = C X + b • Y := by
      dsimp [shift]
      simp only [eval₂_C, coe_eval₂RingHom, eval₂_X]
    have hY : shift Y = Y := by
      dsimp [shift]
      simp only [eval₂_X]
    have hιa : shift (cor11ι a) = cor11ι a := by
      have := congrArg (fun f : R →+* R[X][Y] => f a) hcoeff
      simpa [RingHom.comp_apply] using this
    have haY : shift (a • Y) = a • Y := by
      calc shift (a • Y) = shift (cor11ι a * Y) := by simp [Algebra.smul_def, cor11_hAlg]
        _ = shift (cor11ι a) * shift Y := by simp
        _ = shift (cor11ι a) * Y := by simp [hY]
        _ = cor11ι a * Y := by simpa [hιa]
        _ = a • Y := by simp [Algebra.smul_def, cor11_hAlg]
    have hX : shift (C X + a • Y) = C X + (a + b) • Y := by
      calc shift (C X + a • Y) = shift (C X) + shift (a • Y) := by simp only [map_add]
        _ = (C X + b • Y) + a • Y := by simp only [hCX, haY]
        _ = C X + (a + b) • Y := by simp only [add_comm, add_smul, add_assoc]
    have := Polynomial.hom_eval₂ (v i) cor11ι shift (C X + a • Y)
    simpa only [cor11vxy, hcoeff, hX] using this
  have hab : UnimodularVectorEquiv (cor11vxy v b) (cor11vxy v (a + b)) := by
    simpa [hx, hxy] using unimodularVectorEquiv_map shift ha
  exact (unimodularVectorEquiv_equivalence).trans hb hab

omit [IsDomain R] in
/-- `cor11IdealCarrier v` is closed under scalar multiplication (i.e. multiplication in `R`). -/
lemma cor11Ideal_smul_mem (v : s → R[X]) (r : R) {a : R} (ha : a ∈ cor11IdealCarrier v) :
    r * a ∈ cor11IdealCarrier v := by
  let scaleY : R[X][Y] →+* R[X][Y] :=
    Polynomial.eval₂RingHom (C : R[X] →+* R[X][Y]) (r • Y)
  have hx : (fun i : s => scaleY (cor11vx v i)) = cor11vx v := by
    funext i
    dsimp [scaleY, cor11vx]
    simp only [eval₂_C]
  have hxy : (fun i : s => scaleY (cor11vxy v a i)) = cor11vxy v (r * a) := by
    funext i
    have hcoeff : scaleY.comp cor11ι = cor11ι := by
      ext x
      dsimp [scaleY, cor11ι]
      simp only [eval₂_C]
    have hCX : scaleY (C X) = C X := by
      dsimp [scaleY]
      simp only [eval₂_C]
    have hY : scaleY Y = r • Y := by
      dsimp [scaleY]
      simp only [eval₂_X]
    have hιa : scaleY (cor11ι a) = cor11ι a := by
      simpa [RingHom.comp_apply] using congrArg (fun f : R →+* R[X][Y] => f a) hcoeff
    have hYa : scaleY (a • Y) = (r * a) • Y := by
      have hιr : (r : R) • Y = cor11ι r * Y := by simp [Algebra.smul_def, cor11_hAlg, cor11ι]
      calc
        _ = scaleY (cor11ι a) * scaleY Y := by
          simp only [Algebra.smul_def, cor11_hAlg, RingHom.coe_comp, Function.comp_apply, map_mul]
        _ = cor11ι a * (cor11ι r * Y) := by rw [hY, hιa, hιr]
        _ = (cor11ι a * cor11ι r) * Y := by rw [mul_assoc]
        _ = cor11ι (a * r) * Y := by rw [map_mul]
        _ = cor11ι (r * a) * Y := by
          simp only [mul_comm, RingHom.coe_comp, Function.comp_apply, map_mul]
        _ = (r * a) • Y := by simp [Algebra.smul_def, cor11_hAlg, cor11ι]
    have hX : scaleY (C X + a • Y) = C X + (r * a) • Y := by
      simp only [map_add, hCX, hYa]
    have := Polynomial.hom_eval₂ (v i) cor11ι scaleY (C X + a • Y)
    simpa only [cor11vxy, hcoeff, hX] using this
  simpa [cor11IdealCarrier, hx, hxy] using unimodularVectorEquiv_map scaleY ha

def cor11Ideal (v : s → R[X]) : Ideal R :=
  { carrier := cor11IdealCarrier v
    zero_mem' := cor11Ideal_zero_mem v
    add_mem' := cor11Ideal_add_mem v
    smul_mem' := cor11Ideal_smul_mem v }

theorem cor11Ideal_eq_top (v : s → R[X]) (hv : IsUnimodular v) (h : ∃ i : s, (v i).Monic) :
    cor11Ideal v = ⊤ := by
  let I : Ideal R := cor11Ideal v
  by_contra hI
  rcases Ideal.exists_le_maximal I hI with ⟨m, hm, hIm⟩
  let S : Submonoid R := Ideal.primeCompl m
  have hS0 : (0 : R) ∉ S := by simp [S, Ideal.primeCompl]
  have hs : S ≤ nonZeroDivisors R := le_nonZeroDivisors_of_noZeroDivisors hS0
  let vS : s → (Localization S)[X] := fun i => (v i).map (algebraMap R (Localization S))
  have hvS : IsUnimodular vS := by
    have h1 : (1 : R[X]) ∈ Ideal.span (Set.range v) := by
      rw [hv]
      exact Submodule.mem_top
    rcases (Ideal.mem_span_range_iff_exists_fun).1 h1 with ⟨c, hc⟩
    let fX : R[X] →+* (Localization S)[X] := Polynomial.mapRingHom (algebraMap R (Localization S))
    have hc' : (∑ i : s, fX (c i) * fX (v i)) = 1 := by
      simpa [map_sum, map_mul, fX] using congrArg fX hc
    have : (1 : (Localization S)[X]) ∈ Ideal.span (Set.range vS) := by
      refine (Ideal.mem_span_range_iff_exists_fun).2 ?_
      refine ⟨fun i => fX (c i), ?_⟩
      simpa [vS, map_sum, map_mul, fX] using hc'
    unfold IsUnimodular
    exact (Ideal.eq_top_iff_one _).2 this
  have hmonicS : ∃ i : s, (vS i).Monic := by
    rcases h with ⟨i, hi⟩
    refine ⟨i, ?_⟩
    simpa [vS] using hi.map (algebraMap R (Localization S))
  have : IsLocalRing (Localization S) := by
    have : m.IsPrime := hm.isPrime
    simpa [S, Localization.AtPrime] using (Localization.AtPrime.isLocalRing (P := m))
  have hloc : UnimodularVectorEquiv vS
      (fun i => C (algebraMap R (Localization S) ((v i).eval 0))) := by
    have hev0 : (fun i => C ((vS i).eval 0)) = fun i => C (algebraMap R (Localization S) ((v i).eval 0)) := by
      funext i
      have : (vS i).eval 0 = algebraMap R (Localization S) ((v i).eval 0) := by
        simpa [vS] using (Polynomial.eval_zero_map (algebraMap R (Localization S)) (v i))
      simp [this]
    simpa [hev0] using cor9 vS hvS hmonicS
  rcases lem10 hs v hloc with ⟨c, hc⟩
  exact c.2 (hIm hc)

/-- From a localization equivalence `v(x) ∼ v(0)` at a maximal ideal, produce `q ∉ m` with
`v(x) ∼ v(x + qy)` over `R[x,y]`. -/
theorem cor11IdealCarrier_exists_not_mem_maximal_of_local_equiv (v : s → R[X]) (m : Ideal R)
    [hm : m.IsMaximal]
    (hloc :
      let Rm := Localization m.primeCompl
      let ι : R →+* Rm := algebraMap R Rm
      UnimodularVectorEquiv (fun i => (v i).map ι) (fun i => C (ι ((v i).eval 0)))) :
    ∃ q : R, q ∈ cor11IdealCarrier v ∧ q ∉ m := by
  classical
  haveI : m.IsPrime := hm.isPrime
  let S : Submonoid R := m.primeCompl
  have hS0 : (0 : R) ∉ S := by simp [S, Ideal.mem_primeCompl_iff]
  have hs : S ≤ nonZeroDivisors R := le_nonZeroDivisors_of_noZeroDivisors hS0
  rcases lem10 hs v (by simpa [S] using hloc) with ⟨c, hc⟩
  refine ⟨(c : R), ?_, ?_⟩
  · show UnimodularVectorEquiv (cor11vx v) (cor11vxy v (c : R))
    show
      UnimodularVectorEquiv (fun i : s => C (v i))
        (fun i : s =>
          (v i).eval₂ ((C : R[X] →+* R[X][Y]).comp (C : R →+* R[X])) (C X + (c : R) • Y))
    exact hc
  · exact (Ideal.mem_primeCompl_iff).1 c.2

/-- A maximal-ideal criterion for `cor11Ideal v = ⊤`. -/
theorem cor11Ideal_eq_top_of_forall_maximal (v : s → R[X])
    (h : ∀ m : Ideal R, m.IsMaximal → ∃ q : R, q ∈ cor11IdealCarrier v ∧ q ∉ m) :
    cor11Ideal v = ⊤ := by
  classical
  by_contra hI
  rcases Ideal.exists_le_maximal (cor11Ideal v) hI with ⟨m, hm, hIm⟩
  rcases h m hm with ⟨q, hqI, hqnm⟩
  exact hqnm (hIm hqI)

/-- A local-to-global form of `cor11`: if `v(x) ∼ v(0)` holds after localizing at *every* maximal
ideal of the coefficient ring, then it already holds over the original ring. -/
theorem cor11_of_forall_maximal_local_equiv (v : s → R[X])
    (hloc :
      ∀ m : Ideal R, [m.IsMaximal] →
        let Rm := Localization m.primeCompl
        let ι : R →+* Rm := algebraMap R Rm
        UnimodularVectorEquiv (fun i => (v i).map ι) (fun i => C (ι ((v i).eval 0)))) :
    UnimodularVectorEquiv v (fun i => C ((v i).eval 0)) := by
  classical
  let I : Ideal R := cor11Ideal v
  have hI : I = ⊤ := by
    have hmax :
        ∀ m : Ideal R, m.IsMaximal → ∃ q : R, q ∈ cor11IdealCarrier v ∧ q ∉ m := by
      intro m hm
      haveI : m.IsMaximal := hm
      exact cor11IdealCarrier_exists_not_mem_maximal_of_local_equiv (v := v) m (hloc m)
    simpa [I] using cor11Ideal_eq_top_of_forall_maximal (v := v) hmax
  have h1 : (1 : R) ∈ I := by simp [I, hI]
  have hI1 : UnimodularVectorEquiv (cor11vx v) (cor11vxy v 1) := h1
  let ev0 : R[X] →+* R[X] := Polynomial.eval₂RingHom (C : R →+* R[X]) 0
  let evXY : R[X][Y] →+* R[X] := Polynomial.eval₂RingHom ev0 X
  have hev0 (i : s) : ev0 (v i) = C ((v i).eval 0) := by
    simp [ev0, Polynomial.coeff_zero_eq_eval_zero]
  have hevXY_vx : (fun i => evXY (cor11vx v i)) = fun i => C ((v i).eval 0) := by
    funext i
    simp [evXY, ev0, hev0 i]
  have hevXY_vxy : (fun i => evXY (cor11vxy v 1 i)) = v := by
    funext i
    have hcoeff : evXY.comp cor11ι = (C : R →+* R[X]) := by
      ext r
      simp [evXY, ev0, cor11ι]
    have hX : evXY (C X + Y) = X := by simp [evXY, ev0]
    have hhom := Polynomial.hom_eval₂ (v i) cor11ι evXY (C X + Y)
    have : evXY (cor11vxy v 1 i) = (v i).eval₂ (C : R →+* R[X]) X := by
      simpa [cor11vxy, cor11ι, one_smul, hcoeff, hX] using hhom
    simpa [Polynomial.eval₂_C_X] using this
  have hmain : UnimodularVectorEquiv (fun i => C ((v i).eval 0)) v := by
    simpa [hevXY_vx, hevXY_vxy] using unimodularVectorEquiv_map evXY hI1
  exact unimodularVectorEquiv_equivalence.symm hmain

/-- Suppose $R$ is any ring, and $v(x) \in R[x]^s$ is a unimodular vector one of whose
  leading coefficients is one. Then $v(x) \sim v(0)$. -/
theorem cor11 (v : s → R[X]) (hv : IsUnimodular v) (h : ∃ i : s, (v i).Monic) :
    UnimodularVectorEquiv v (fun i => C ((v i).eval 0)) :=
  let I : Ideal R := cor11Ideal v
  have hI : I = ⊤ := cor11Ideal_eq_top v hv h
  have h1 : (1 : R) ∈ I := by simp [hI]
  have hI1 : UnimodularVectorEquiv (cor11vx v) (cor11vxy v 1) := h1
  let ev0 : R[X] →+* R[X] := Polynomial.eval₂RingHom (C : R →+* R[X]) 0
  let evXY : R[X][Y] →+* R[X] := Polynomial.eval₂RingHom ev0 X
  have hev0 (i : s) : ev0 (v i) = C ((v i).eval 0) := by
    simp [ev0, Polynomial.coeff_zero_eq_eval_zero]
  have hevXY_vx : (fun i => evXY (cor11vx v i)) = fun i => C ((v i).eval 0) := by
    funext i
    simp [evXY, ev0, hev0 i]
  have hevXY_vxy : (fun i => evXY (cor11vxy v 1 i)) = v := by
    funext i
    have hcoeff : evXY.comp cor11ι = (C : R →+* R[X]) := by
      ext r
      simp [evXY, ev0, cor11ι]
    have hX : evXY (C X + Y) = X := by simp [evXY, ev0]
    have hhom := Polynomial.hom_eval₂ (v i) cor11ι evXY (C X + Y)
    have : evXY (cor11vxy v 1 i) = (v i).eval₂ (C : R →+* R[X]) X := by
      simpa [cor11vxy, cor11ι, one_smul, hcoeff, hX] using hhom
    simpa [Polynomial.eval₂_C_X] using this
  have hmain : UnimodularVectorEquiv (fun i => C ((v i).eval 0)) v := by
    simpa [hevXY_vx, hevXY_vxy] using unimodularVectorEquiv_map evXY hI1
  unimodularVectorEquiv_equivalence.symm hmain

/-- A variant of `cor11`: it suffices that some component has *unit* leading coefficient. -/
theorem cor11_of_isUnit_leadingCoeff (v : s → R[X]) (hv : IsUnimodular v)
    (h : ∃ i : s, IsUnit (v i).leadingCoeff) :
    UnimodularVectorEquiv v (fun i => C ((v i).eval 0)) := by
  classical
  rcases h with ⟨i, hi⟩
  rcases hi with ⟨u, hu⟩
  let b : R := (↑(u⁻¹) : R)
  have hb : b * (v i).leadingCoeff = 1 := by
    calc b * (v i).leadingCoeff = (↑(u⁻¹) : R) * (↑u : R) := by simp [b, hu]
      _ = 1 := by simp
  have hmonic : (Polynomial.C b * v i).Monic := monic_C_mul_of_mul_leadingCoeff_eq_one hb
  have hunitC : IsUnit (Polynomial.C b : R[X]) := by
    have : IsUnit b := ⟨u⁻¹, rfl⟩
    simpa [Polynomial.isUnit_C] using this
  let v' : s → R[X] := Function.update v i (Polynomial.C b * v i)
  have hvv' : UnimodularVectorEquiv v v' :=
    unimodularVectorEquiv_update_mul_isUnit (R := R) (s := s) i (Polynomial.C b) hunitC v
  have hv' : IsUnimodular v' :=
    (isUnimodular_iff_of_unimodularVectorEquiv (R := R) (s := s) hvv').1 hv
  have hmonic' : ∃ j : s, (v' j).Monic := by refine ⟨i, by simp [v', hmonic]⟩
  let w0 : s → R[X] := fun j => C ((v j).eval 0)
  let w1 : s → R[X] := fun j => C ((v' j).eval 0)
  have hcor : UnimodularVectorEquiv v' w1 := by simpa [w1] using cor11 v' hv' hmonic'
  have hw1 : w1 = Function.update w0 i (Polynomial.C b * w0 i) := by
    funext j
    by_cases hj : j = i
    · subst hj
      simp only [mul_comm, Function.update_self, eval_mul, eval_C, map_mul, w1, v', w0]
    · simp [w1, w0, v', Function.update, hj]
  have hw0w1 : UnimodularVectorEquiv w0 w1 := by
    have := unimodularVectorEquiv_update_mul_isUnit (R := R) (s := s) i (Polynomial.C b) hunitC w0
    simpa [hw1] using this
  have hw1w0 : UnimodularVectorEquiv w1 w0 := unimodularVectorEquiv_equivalence.symm hw0w1
  exact unimodularVectorEquiv_equivalence.trans hvv' <|
    unimodularVectorEquiv_equivalence.trans hcor hw1w0

end cor11

section thm12_field

variable (R : Type*) [CommRing R] [IsDomain R]
variable {s : Type*}

/-- Unimodularity is preserved under a ring homomorphism. -/
theorem isUnimodular_map_ringHom {A B : Type*} [CommRing A] [CommRing B] (f : A →+* B)
    (v : s → A) (hv : IsUnimodular v) : IsUnimodular fun i => f (v i) := by
  classical
  unfold IsUnimodular at hv ⊢
  have hmap : Ideal.map f (Ideal.span (Set.range v)) = ⊤ := by
    simpa [hv] using (Ideal.map_top (f := f) : Ideal.map f (⊤ : Ideal A) = (⊤ : Ideal B))
  have hrange : (f : A → B) '' Set.range v = Set.range fun i => f (v i) := by
    ext b
    constructor
    · rintro ⟨a, ⟨i, rfl⟩, rfl⟩
      exact ⟨i, rfl⟩
    · rintro ⟨i, rfl⟩
      exact ⟨v i, ⟨i, rfl⟩, rfl⟩
  have hspan : Ideal.span ((f : A → B) '' Set.range v) = ⊤ := by
    simpa [Ideal.map_span] using hmap
  simpa [hrange] using hspan

/-- Unimodularity is preserved under an algebra equivalence. -/
theorem isUnimodular_map_ringEquiv {A B : Type*} [CommRing A] [CommRing B] (e : A ≃+* B)
    (v : s → A) (hv : IsUnimodular v) : IsUnimodular fun i => e (v i) := by
  classical
  unfold IsUnimodular at hv ⊢
  have hmap : Ideal.map (e : A →+* B) (Ideal.span (Set.range v)) = ⊤ := by
    have := congrArg (Ideal.map (e : A →+* B)) hv
    simpa using this.trans (by simpa using (Ideal.map_top (f := (e : A →+* B))))
  have hspan : Ideal.span ((e : A →+* B) '' Set.range v) = ⊤ := by
    simpa [Ideal.map_span] using hmap
  have hrange : (e : A → B) '' Set.range v = Set.range fun i => e (v i) := by
    ext b
    constructor
    · rintro ⟨a, ⟨i, rfl⟩, rfl⟩
      exact ⟨i, rfl⟩
    · rintro ⟨i, rfl⟩
      exact ⟨v i, ⟨i, rfl⟩, rfl⟩
  simpa [hrange] using hspan

variable [Fintype s] [DecidableEq s]

/-- Unimodular-vector equivalence is preserved under an algebra equivalence. -/
theorem unimodularVectorEquiv_map_ringEquiv {A B : Type*} [CommRing A] [CommRing B] (e : A ≃+* B)
    (v w : s → A) (hvw : UnimodularVectorEquiv v w) :
    UnimodularVectorEquiv (fun i => e (v i)) (fun i => e (w i)) := by
  simpa using unimodularVectorEquiv_map (f := (e : A →+* B)) hvw

section monicize

variable {k : Type*} [Field k] {n : ℕ}

open scoped BigOperators

variable (f : MvPolynomial (Fin (n + 1)) k)

/-- `up` is defined as `2 + f.totalDegree`. Any big enough number would work. -/
local notation3 "up" => 2 + f.totalDegree

private lemma lt_up {v : Fin (n + 1) → ℕ} (vlt : ∀ i, v i < up) :
    ∀ l ∈ List.ofFn v, l < up := by
  intro l hl
  rcases ((List.mem_ofFn' v l).1 hl) with ⟨i, rfl⟩
  exact vlt i

/-- `r` maps `(i : Fin (n + 1))` to `up ^ i`. -/
local notation3 "r" => fun (i : Fin (n + 1)) ↦ up ^ i.1

/-- The triangular algebra endomorphism sending `X_i ↦ X_i + c * X_0^(r i)` for `i ≠ 0` and
fixing `X_0`. -/
noncomputable abbrev T1 (c : k) :
    MvPolynomial (Fin (n + 1)) k →ₐ[k] MvPolynomial (Fin (n + 1)) k :=
  MvPolynomial.aeval fun i ↦ if i = 0 then MvPolynomial.X 0 else MvPolynomial.X i + c • MvPolynomial.X 0 ^ r i

private lemma t1_comp_t1_neg (c : k) : (T1 f c).comp (T1 f (-c)) = AlgHom.id _ _ := by
  rw [MvPolynomial.comp_aeval, ← MvPolynomial.aeval_X_left]
  ext i v
  cases i using Fin.cases <;> simp [T1, add_assoc, add_comm]

/-- `T1 f 1` leads to an algebra equivalence `T f`. -/
private noncomputable abbrev T :
    MvPolynomial (Fin (n + 1)) k ≃ₐ[k] MvPolynomial (Fin (n + 1)) k :=
  AlgEquiv.ofAlgHom (T1 f 1) (T1 f (-1)) (t1_comp_t1_neg f 1) (by simpa using t1_comp_t1_neg f (-1))

private lemma sum_r_mul_neq {v w : Fin (n + 1) →₀ ℕ} (vlt : ∀ i, v i < up) (wlt : ∀ i, w i < up)
    (neq : v ≠ w) : (∑ x : Fin (n + 1), r x * v x) ≠ ∑ x : Fin (n + 1), r x * w x := by
  intro h
  refine neq <| Finsupp.ext <| congrFun <| (List.ofFn_inj.mp ?_)
  apply Nat.ofDigits_inj_of_len_eq (Nat.lt_add_right f.totalDegree one_lt_two) (by simp)
      (lt_up (f := f) vlt) (lt_up (f := f) wlt)
  simpa only [Nat.ofDigits_eq_sum_mapIdx, List.mapIdx_eq_ofFn, List.get_ofFn, List.length_ofFn,
      Fin.val_cast, mul_comm, List.sum_ofFn] using h

private lemma degreeOf_zero_t {v : Fin (n + 1) →₀ ℕ} {a : k} (ha : a ≠ 0) :
    ((T f) (MvPolynomial.monomial v a)).degreeOf 0 = ∑ i : Fin (n + 1), (r i) * v i := by
  rw [← MvPolynomial.natDegree_finSuccEquiv, MvPolynomial.monomial_eq, Finsupp.prod_pow v fun a ↦ MvPolynomial.X a]
  simp only [Fin.prod_univ_succ, Fin.sum_univ_succ, map_mul, map_prod, map_pow, AlgEquiv.ofAlgHom_apply,
    MvPolynomial.aeval_C, MvPolynomial.aeval_X, if_pos, Fin.succ_ne_zero, ite_false, one_smul,
    map_add, MvPolynomial.finSuccEquiv_X_zero, MvPolynomial.finSuccEquiv_X_succ, MvPolynomial.algebraMap_eq]
  have h (i : Fin n) :
      (Polynomial.C (MvPolynomial.X (R := k) i) + Polynomial.X ^ r i.succ) ^ v i.succ ≠ 0 :=
    pow_ne_zero (v i.succ) (Polynomial.leadingCoeff_ne_zero.mp <| by
      simp [add_comm, Polynomial.leadingCoeff_X_pow_add_C])
  rw [Polynomial.natDegree_mul (by simp [ha])
      (mul_ne_zero (by simp) (Finset.prod_ne_zero_iff.mpr (fun i _ ↦ h i))),
    Polynomial.natDegree_mul (by simp) (Finset.prod_ne_zero_iff.mpr (fun i _ ↦ h i)),
    Polynomial.natDegree_prod _ _ (fun i _ ↦ h i), MvPolynomial.natDegree_finSuccEquiv,
    MvPolynomial.degreeOf_C]
  simpa only [Polynomial.natDegree_pow, zero_add, Polynomial.natDegree_X, mul_one, Fin.val_zero,
      pow_zero, one_mul, add_right_inj] using
    Finset.sum_congr rfl (fun i _ ↦ by
      rw [add_comm (Polynomial.C _), Polynomial.natDegree_X_pow_add_C, mul_comm])

private lemma degreeOf_t_neq_of_neq {v w : Fin (n + 1) →₀ ℕ} (hv : v ∈ f.support) (hw : w ∈ f.support)
    (neq : v ≠ w) :
    (T f (MvPolynomial.monomial v (MvPolynomial.coeff v f))).degreeOf 0 ≠
      (T f (MvPolynomial.monomial w (MvPolynomial.coeff w f))).degreeOf 0 := by
  rw [degreeOf_zero_t (f := f) (a := MvPolynomial.coeff v f) (by exact (MvPolynomial.mem_support_iff.mp hv)),
    degreeOf_zero_t (f := f) (a := MvPolynomial.coeff w f) (by exact (MvPolynomial.mem_support_iff.mp hw))]
  refine sum_r_mul_neq (f := f) (v := v) (w := w) (fun i ↦ ?_) (fun i ↦ ?_) neq <;>
  · exact lt_of_le_of_lt ((MvPolynomial.monomial_le_degreeOf i ‹_›).trans (MvPolynomial.degreeOf_le_totalDegree f i))
      (by lia)

private lemma leadingCoeff_finSuccEquiv_t {v : Fin (n + 1) →₀ ℕ} :
    (MvPolynomial.finSuccEquiv k n (T f (MvPolynomial.monomial v (MvPolynomial.coeff v f)))).leadingCoeff =
      algebraMap k _ (MvPolynomial.coeff v f) := by
  rw [MvPolynomial.monomial_eq, Finsupp.prod_fintype]
  · simp only [map_mul, map_prod, Polynomial.leadingCoeff_mul, Polynomial.leadingCoeff_prod]
    rw [AlgEquiv.ofAlgHom_apply, MvPolynomial.algHom_C, MvPolynomial.algebraMap_eq,
      MvPolynomial.finSuccEquiv_apply, MvPolynomial.eval₂Hom_C, RingHom.coe_comp]
    simp only [AlgEquiv.ofAlgHom_apply, Function.comp_apply, Polynomial.leadingCoeff_C, map_pow,
      Polynomial.leadingCoeff_pow, MvPolynomial.algebraMap_eq]
    have : ∀ j, (MvPolynomial.finSuccEquiv k n ((T1 f) 1 (MvPolynomial.X j))).leadingCoeff = 1 := fun j ↦ by
      by_cases h : j = 0
      · simp [h, MvPolynomial.finSuccEquiv_apply]
      · simp only [MvPolynomial.aeval_eq_bind₁, MvPolynomial.bind₁_X_right, if_neg h, one_smul,
          map_add, map_pow]
        obtain ⟨i, rfl⟩ := Fin.exists_succ_eq.mpr h
        simp [MvPolynomial.finSuccEquiv_X_succ, MvPolynomial.finSuccEquiv_X_zero, add_comm]
    simp only [this, one_pow, Finset.prod_const_one, mul_one]
  exact fun i ↦ pow_zero _

private lemma T_leadingcoeff_isUnit (fne : f ≠ 0) :
    IsUnit (MvPolynomial.finSuccEquiv k n (T f f)).leadingCoeff := by
  obtain ⟨v, vin, vs⟩ := Finset.exists_max_image f.support
    (fun v ↦ (T f (MvPolynomial.monomial v (MvPolynomial.coeff v f))).degreeOf 0)
    (MvPolynomial.support_nonempty.mpr fne)
  set h := fun w ↦ MvPolynomial.monomial w (MvPolynomial.coeff w f)
  simp only [← MvPolynomial.natDegree_finSuccEquiv] at vs
  replace vs :
      ∀ x ∈ f.support \ {v},
        (MvPolynomial.finSuccEquiv k n (T f (h x))).degree <
          (MvPolynomial.finSuccEquiv k n (T f (h v))).degree := by
    intro x hx
    obtain ⟨h1, h2⟩ := Finset.mem_sdiff.mp hx
    apply Polynomial.degree_lt_degree <| lt_of_le_of_ne (vs x h1) ?_
    simpa only [MvPolynomial.natDegree_finSuccEquiv] using
      degreeOf_t_neq_of_neq (f := f) (hv := h1) (hw := vin) (neq := by
        intro hxv
        exact h2 (Finset.mem_singleton.2 hxv))
  have coeff :
      (MvPolynomial.finSuccEquiv k n (T f (h v + ∑ x ∈ f.support \ {v}, h x))).leadingCoeff =
        (MvPolynomial.finSuccEquiv k n (T f (h v))).leadingCoeff := by
    simp only [map_add, map_sum]
    rw [add_comm]
    apply Polynomial.leadingCoeff_add_of_degree_lt <| (lt_of_le_of_lt (Polynomial.degree_sum_le _ _) ?_)
    have h2 : h v ≠ 0 := by
      simpa [h] using (MvPolynomial.mem_support_iff.mp vin)
    have h2' : (MvPolynomial.finSuccEquiv k n (T f (h v))) ≠ 0 := fun eq ↦ h2 <|
      by simpa only [map_eq_zero_iff _ (AlgEquiv.injective _)] using eq
    exact (Finset.sup_lt_iff (Ne.bot_lt (fun x ↦ h2' <| Polynomial.degree_eq_bot.mp x))).mpr vs
  nth_rw 2 [← MvPolynomial.support_sum_monomial_coeff f]
  rw [Finset.sum_eq_add_sum_diff_singleton vin h]
  rw [leadingCoeff_finSuccEquiv_t (f := f)] at coeff
  simpa only [coeff, MvPolynomial.algebraMap_eq] using (MvPolynomial.mem_support_iff.mp vin).isUnit.map MvPolynomial.C

/-- For a nonzero multivariable polynomial over a field, there exists an algebra automorphism which
makes its `finSuccEquiv` image have invertible leading coefficient (Nagata's trick). -/
theorem exists_algEquiv_isUnit_leadingCoeff_finSuccEquiv (f : MvPolynomial (Fin (n + 1)) k) (fne : f ≠ 0) :
    ∃ e : MvPolynomial (Fin (n + 1)) k ≃ₐ[k] MvPolynomial (Fin (n + 1)) k,
      IsUnit (MvPolynomial.finSuccEquiv k n (e f)).leadingCoeff := by
  refine ⟨T f, ?_⟩
  simpa using T_leadingcoeff_isUnit (f := f) (n := n) fne

omit [DecidableEq s] in
/-- For a unimodular vector over `k[x₀,…,xₙ]` (with `k` a field), there exists an algebra
automorphism such that one component becomes a polynomial in `x₀` with invertible leading
coefficient, after identifying `k[x₀,…,xₙ] ≃ₐ[k] (k[x₁,…,xₙ])[X]` via `finSuccEquiv`. -/
theorem exists_algEquiv_exists_isUnit_leadingCoeff_finSuccEquiv (n : ℕ)
    (v : s → MvPolynomial (Fin (n + 1)) k) (hv : IsUnimodular v) :
    ∃ e : MvPolynomial (Fin (n + 1)) k ≃ₐ[k] MvPolynomial (Fin (n + 1)) k,
      ∃ i : s, IsUnit (MvPolynomial.finSuccEquiv k n (e (v i))).leadingCoeff := by
  have h1 :
      (1 : MvPolynomial (Fin (n + 1)) k) ∈ Ideal.span (Set.range v) := by
    unfold IsUnimodular at hv
    simp [hv]
  rcases (Ideal.mem_span_range_iff_exists_fun).1 h1 with ⟨c, hc⟩
  have hex : ∃ i : s, v i ≠ 0 := by
    by_contra h0
    have hv0 : ∀ i : s, v i = 0 := by
      intro i
      by_contra hi
      exact h0 ⟨i, hi⟩
    have : (∑ i : s, c i * v i) = 0 := by simp [hv0]
    exact (one_ne_zero : (1 : MvPolynomial (Fin (n + 1)) k) ≠ 0) (by simpa [this] using hc.symm)
  rcases hex with ⟨i, hi⟩
  rcases exists_algEquiv_isUnit_leadingCoeff_finSuccEquiv (k := k) (n := n) (f := v i) hi with ⟨e, he⟩
  exact ⟨e, i, he⟩

end monicize

/-- Field case of the “unimodular vector” theorem, with variables indexed by `Fin n`. -/
theorem thm12_fin {k : Type*} [Field k] (n : ℕ) (o : s) (v : s → MvPolynomial (Fin n) k)
    (hv : IsUnimodular v) : UnimodularVectorEquiv v (fun i => if i = o then 1 else 0) := by
  classical
  induction n with
  | zero =>
    let e : MvPolynomial (Fin 0) k ≃+* k := MvPolynomial.isEmptyRingEquiv k (Fin 0)
    have hv' : IsUnimodular fun i => e (v i) := isUnimodular_map_ringEquiv e v hv
    have hstd : IsUnimodular fun i : s => if i = o then (1 : k) else 0 := by
      unfold IsUnimodular
      refine
        Ideal.eq_top_of_isUnit_mem
          (I := Ideal.span (Set.range fun i : s => if i = o then (1 : k) else 0)) (x := (1 : k)) ?_
          isUnit_one
      exact Ideal.subset_span ⟨o, by simp⟩
    have h' :
        UnimodularVectorEquiv (fun i => e (v i)) (fun i => if i = o then (1 : k) else 0) := by
      simpa using unimodularVectorEquiv_of_pid (R := k) (s := s) hv' hstd
    have h'' :
        UnimodularVectorEquiv v (fun i => if i = o then (1 : MvPolynomial (Fin 0) k) else 0) := by
      have := unimodularVectorEquiv_map_ringEquiv e.symm (fun i => e (v i))
        (fun i : s => if i = o then (1 : k) else 0) h'
      simpa using this
    simpa using h''
  | succ n ih =>
    let A := MvPolynomial (Fin n) k
    let φ : MvPolynomial (Fin (n + 1)) k ≃ₐ[k] Polynomial A := MvPolynomial.finSuccEquiv k n
    rcases exists_algEquiv_exists_isUnit_leadingCoeff_finSuccEquiv (k := k) (s := s) (n := n) v hv with ⟨e, i, hu⟩
    let w : s → Polynomial A := fun j => φ (e (v j))
    have hw : IsUnimodular w := by
      have hv1 : IsUnimodular fun j => e (v j) := isUnimodular_map_ringEquiv e.toRingEquiv v hv
      simpa [w, φ] using isUnimodular_map_ringEquiv φ.toRingEquiv (fun j => e (v j)) hv1
    rcases hu with ⟨u, hu⟩
    let b : A := (↑(u⁻¹) : A)
    have hb : b * (w i).leadingCoeff = 1 := by
      have : (w i).leadingCoeff = (u : A) := by simpa [w, φ] using hu.symm
      simp [b, this]
    have hmonic : (Polynomial.C b * w i).Monic := monic_C_mul_of_mul_leadingCoeff_eq_one hb
    have hunitC : IsUnit (Polynomial.C b : Polynomial A) := by
      have : IsUnit b := ⟨u⁻¹, rfl⟩
      simpa [Polynomial.isUnit_C] using this
    let w' : s → Polynomial A := Function.update w i (Polynomial.C b * w i)
    have hww' : UnimodularVectorEquiv w w' :=
      unimodularVectorEquiv_update_mul_isUnit (R := A) (s := s) i (Polynomial.C b) hunitC w
    have hw' : IsUnimodular w' :=
      (isUnimodular_iff_of_unimodularVectorEquiv (R := A) (s := s) hww').1 hw
    have hmonic' : ∃ j : s, (w' j).Monic := by
      refine ⟨i, ?_⟩
      simp [w', hmonic]
    have hcor : UnimodularVectorEquiv w' (fun j => Polynomial.C ((w' j).eval 0)) :=
      cor11 (R := A) (s := s) w' hw' hmonic'
    let ev0 : Polynomial A →+* A := Polynomial.evalRingHom (R := A) 0
    let v0 : s → A := fun j => ev0 (w' j)
    have hv0 : IsUnimodular v0 := isUnimodular_map_ringHom ev0 w' hw'
    have hih : UnimodularVectorEquiv v0 (fun j => if j = o then (1 : A) else 0) := ih v0 hv0
    have hmap :
        UnimodularVectorEquiv (fun j => Polynomial.C (v0 j))
          (fun j : s => if j = o then (1 : Polynomial A) else 0) := by
      have := unimodularVectorEquiv_map (s := s) (Polynomial.C : A →+* Polynomial A) hih
      simpa [v0] using this
    have hcor' : UnimodularVectorEquiv w' (fun j : s => if j = o then (1 : Polynomial A) else 0) := by
      have hcor0 : UnimodularVectorEquiv w' (fun j => Polynomial.C (v0 j)) := by
        simpa [v0, ev0] using hcor
      exact unimodularVectorEquiv_equivalence.trans hcor0 hmap
    have hwstd : UnimodularVectorEquiv w (fun j : s => if j = o then (1 : Polynomial A) else 0) :=
      unimodularVectorEquiv_equivalence.trans hww' hcor'
    have h' :
        UnimodularVectorEquiv (fun j => e (v j))
          (fun j : s => if j = o then (1 : MvPolynomial (Fin (n + 1)) k) else 0) := by
      let φr : MvPolynomial (Fin (n + 1)) k ≃+* Polynomial A := φ.toRingEquiv
      have := unimodularVectorEquiv_map_ringEquiv φr.symm w
        (fun j : s => if j = o then (1 : Polynomial A) else 0) hwstd
      have hcomp : (fun j => φr.symm (w j)) = fun j => e (v j) := by
        funext j
        simpa [w, φr] using φr.symm_apply_apply (e (v j))
      simpa [hcomp] using this
    have h'' :
        UnimodularVectorEquiv v (fun j : s => if j = o then (1 : MvPolynomial (Fin (n + 1)) k) else 0) := by
      let er : MvPolynomial (Fin (n + 1)) k ≃+* MvPolynomial (Fin (n + 1)) k := e.toRingEquiv
      have := unimodularVectorEquiv_map_ringEquiv er.symm (fun j => er (v j))
        (fun j : s => if j = o then (1 : MvPolynomial (Fin (n + 1)) k) else 0) h'
      have hcomp : (fun j => er.symm (er (v j))) = v := by
        funext j
        simpa [er] using er.symm_apply_apply (v j)
      simpa [hcomp] using this
    simpa using h''

/-- Let `k` be a field and `σ` a finite set of variables. Any unimodular vector in `k[σ]` is
equivalent to a standard basis vector. -/
theorem thm12_field {k : Type*} [Field k] {σ : Type*} [Fintype σ] [DecidableEq σ]
    (o : s) (v : s → MvPolynomial σ k) (hv : IsUnimodular v) :
    UnimodularVectorEquiv v (fun i => if i = o then 1 else 0) := by
  classical
  let n : ℕ := Fintype.card σ
  let eσ : σ ≃ Fin n := Fintype.equivFin σ
  let ρ : MvPolynomial σ k ≃ₐ[k] MvPolynomial (Fin n) k := MvPolynomial.renameEquiv k eσ
  let v' : s → MvPolynomial (Fin n) k := fun i => ρ (v i)
  have hv' : IsUnimodular v' := isUnimodular_map_ringEquiv ρ.toRingEquiv v hv
  have h' : UnimodularVectorEquiv v' (fun i : s => if i = o then 1 else 0) := thm12_fin n o v' hv'
  have := unimodularVectorEquiv_map_ringEquiv ρ.symm.toRingEquiv v'
    (fun i : s => if i = o then 1 else 0) h'
  simpa [v', ρ] using this

end thm12_field

section thm12_pid

theorem unimodularVectorEquiv_update_add_ring {A : Type*} [CommRing A] (i j : s) (hij : i ≠ j)
    (c : A) (v : s → A) :
    UnimodularVectorEquiv v (Function.update v i (v i + c * v j)) := by
  let M : Matrix s s A := Matrix.transvection i j c
  have hdet : IsUnit (Matrix.det M) := by
    have : Matrix.det M = 1 := by
      simpa [M] using Matrix.det_transvection_of_ne (i := i) (j := j) hij c
    simp [this]
  refine ⟨Matrix.GeneralLinearGroup.mk'' M hdet, ?_⟩
  ext k
  by_cases hk : k = i
  · subst hk
    simp [M, Matrix.transvection, Matrix.mulVec, dotProduct, Matrix.one_apply, Matrix.single_apply,
      Function.update, Finset.sum_add_distrib, add_mul]
  · simp [M, Matrix.transvection, Matrix.mulVec, dotProduct, Function.update, hk, Ne.symm hk,
      Matrix.one_apply]

theorem unimodularVectorEquiv_update_add_sum {A : Type*} [CommRing A] (i : s) (t : Finset s)
    (ht : i ∉ t) (c : s → A) (v : s → A) :
    UnimodularVectorEquiv v (Function.update v i (v i + ∑ j ∈ t, c j * v j)) := by
  classical
  let vOf : Finset s → s → A := fun t =>
    Function.update v i (v i + ∑ j ∈ t, c j * v j)
  have hvOf : ∀ t : Finset s, i ∉ t → UnimodularVectorEquiv v (vOf t) := by
    intro t
    refine Finset.induction_on t ?_ ?_
    · intro _
      have h0 : vOf (∅ : Finset s) = v := by
        funext j
        by_cases hj : j = i
        · subst hj
          simp [vOf]
        · simp [vOf, hj]
      simpa [h0] using (unimodularVectorEquiv_equivalence (R := A) (s := s)).1 v
    · intro j t hj_notmem ih ht
      have ht' : i ∉ t := by
        intro hi
        exact ht (Finset.mem_insert_of_mem hi)
      have hij : j ≠ i := by
        intro hji
        have : i ∈ insert j t := by
          subst j
          exact Finset.mem_insert_self i t
        exact ht this
      have ih' : UnimodularVectorEquiv v (vOf t) := ih ht'
      have hadd :
          UnimodularVectorEquiv (vOf t)
            (Function.update (vOf t) i ((vOf t) i + c j * (vOf t) j)) := by
        simpa using
          unimodularVectorEquiv_update_add_ring (A := A) (s := s) i j (Ne.symm hij) (c j) (vOf t)
      have hstep :
          Function.update (vOf t) i ((vOf t) i + c j * (vOf t) j) = vOf (insert j t) := by
        funext x
        by_cases hx : x = i
        · subst hx
          have hvj : (vOf t) j = v j := by
            simp [vOf, hij]
          simp [vOf, Function.update, hvj, Finset.sum_insert, hj_notmem, add_left_comm, add_comm]
        · simp [vOf, Function.update, hx]
      exact
        (unimodularVectorEquiv_equivalence (R := A) (s := s)).trans ih'
          (by simpa [hstep] using hadd)
  simpa [vOf] using hvOf t ht

lemma Ideal.height_add_one_le_of_forall_notMem_minimalPrimes {A : Type*} [CommRing A] (I : Ideal A)
    (a : A) (k : ℕ∞) (hk : k ≤ I.height) (ha : ∀ p ∈ I.minimalPrimes, a ∉ p) :
    k + 1 ≤ (I ⊔ Ideal.span ({a} : Set A)).height := by
  classical
  -- Unfold `Ideal.height` and bound each minimal prime from below.
  refine le_iInf₂ ?_
  intro P hP
  haveI : P.IsPrime := Ideal.minimalPrimes_isPrime hP
  -- Pick a minimal prime `q` over `I` contained in `P`.
  have hIP : I ≤ P := le_trans le_sup_left hP.1.2
  rcases Ideal.exists_minimalPrimes_le (I := I) (J := P) hIP with ⟨q, hq, hq_le_P⟩
  haveI : q.IsPrime := Ideal.minimalPrimes_isPrime hq
  have haq : a ∉ q := ha q hq
  have hI_le_q : I.height ≤ q.primeHeight := by
    simpa [Ideal.height] using iInf₂_le q hq
  have hkq : k ≤ q.primeHeight := le_trans hk hI_le_q
  -- `a ∈ P` but `a ∉ q`, hence `q < P`.
  have haP : a ∈ P := by
    have haSpan : a ∈ Ideal.span ({a} : Set A) := Ideal.subset_span (by simp)
    exact (le_trans le_sup_right hP.1.2) haSpan
  have hq_ne_P : q ≠ P := by
    intro h
    subst h
    exact haq haP
  have hq_lt_P : q < P := lt_of_le_of_ne hq_le_P hq_ne_P
  have hqp : q.primeHeight + 1 ≤ P.primeHeight := Ideal.primeHeight_add_one_le_of_lt hq_lt_P
  have hkq' : k + 1 ≤ q.primeHeight + 1 := add_le_add_left hkq 1
  exact le_trans hkq' hqp

theorem exists_equiv_exists_index_height_gt_krullDim (n : ℕ) [IsNoetherianRing R]
    (v : s → MvPolynomial (Fin (n + 1)) R) (hv : IsUnimodular v)
    (hs : ringKrullDim R + 1 < (↑(Fintype.card s) : WithBot ℕ∞)) :
    ∃ o : s,
      ∃ v' : s → MvPolynomial (Fin (n + 1)) R,
        UnimodularVectorEquiv v v' ∧
          ringKrullDim R <
            (Ideal.span (Set.range (fun i : s => if i = o then 0 else v' i))).height := by
  classical
  let A := MvPolynomial (Fin (n + 1)) R
  haveI : IsNoetherianRing A := by
    dsimp [A]
    infer_instance
  have hr_ne_bot : ringKrullDim R ≠ (⊥ : WithBot ℕ∞) := by
    -- `PrimeSpectrum R` is nonempty for a domain, hence `dim R ≠ -∞`.
    have hne : Nonempty (PrimeSpectrum R) := ⟨⟨⊥, Ideal.isPrime_bot⟩⟩
    unfold ringKrullDim
    exact (Order.krullDim_ne_bot_iff (α := PrimeSpectrum R)).2 hne
  have hs_pos : 0 < Fintype.card s := by
    by_contra h0
    have hcard0 : Fintype.card s = 0 := Nat.eq_zero_of_not_pos h0
    have hs0 : ringKrullDim R + 1 < (0 : WithBot ℕ∞) := by
      simpa [hcard0] using hs
    have hs0' : ringKrullDim R + 1 < (↑(⊥ : ℕ∞) : WithBot ℕ∞) := by
      simpa using hs0
    have hbot : ringKrullDim R + 1 = (⊥ : WithBot ℕ∞) := (WithBot.lt_coe_bot).1 hs0'
    have hr_bot : ringKrullDim R = (⊥ : WithBot ℕ∞) := by
      cases h : ringKrullDim R <;> simp [h] at hbot ⊢
    exact hr_ne_bot hr_bot
  have hs_nonempty : Nonempty s := (Fintype.card_pos_iff).1 hs_pos
  let o : s := Classical.choice hs_nonempty
  let t : Finset s := Finset.univ.erase o
  -- For a finite subset `S ⊆ t`, let `I(S)` be the ideal generated by the coordinates in `S`.
  let Iof (S : Finset s) (w : s → A) : Ideal A :=
    Ideal.span (Set.range fun j : s => if j ∈ S then w j else 0)
  have hbuild :
      ∀ S : Finset s, S ⊆ t →
        ∃ w : s → A, UnimodularVectorEquiv v w ∧ (S.card : ℕ∞) ≤ (Iof S w).height := by
    intro S
    refine Finset.induction_on S ?_ ?_
    · intro _
      refine ⟨v, (unimodularVectorEquiv_equivalence (R := A) (s := s)).1 v, ?_⟩
      -- `I(∅) = ⊥`, so its height is `0`.
      have hbot : Iof (∅ : Finset s) v = (⊥ : Ideal A) := by
        ext x
        simp [Iof]
      simp [hbot]
    · intro i S hi_notmem ih hsub
      have hsubS : S ⊆ t := by
        intro x hx
        exact hsub (Finset.mem_insert_of_mem hx)
      have hi_t : i ∈ t := hsub (Finset.mem_insert_self i S)
      rcases ih hsubS with ⟨w, hvw, hheight⟩
      have hw_unimod : IsUnimodular (s := s) (R := A) w := by
        exact (isUnimodular_iff_of_unimodularVectorEquiv_ring (A := A) (s := s) hvw).1 hv
      let I : Ideal A := Iof S w
      -- The ideal generated by the remaining coordinates (outside `insert i S`).
      let J : Ideal A :=
        Ideal.span (Set.range fun j : s => if j ∈ insert i S then 0 else w j)
      -- First choose `y ∈ J` so that `w i + y` avoids all minimal primes of `I`.
      have hfin : (I.minimalPrimes).Finite :=
        Ideal.finite_minimalPrimes_of_isNoetherianRing A I
      let P : Finset (Ideal A) := hfin.toFinset
      have hmemP : ∀ p : Ideal A, p ∈ P ↔ p ∈ I.minimalPrimes := fun p =>
        (Set.Finite.mem_toFinset hfin)
      have havoidP :
          ∃ y : A, y ∈ J ∧ ∀ p ∈ P, w i + y ∉ p := by
        -- Induct over finite subsets of `P`.
        classical
        let motive (Q : Finset (Ideal A)) : Prop :=
          Q ⊆ P → ∃ y : A, y ∈ J ∧ ∀ q ∈ Q, w i + y ∉ q
        have h0 : motive ∅ := by
          intro _
          refine ⟨0, by simp, ?_⟩
          intro q hq
          cases hq
        have hstep :
            ∀ (p : Ideal A) (Q : Finset (Ideal A)),
              p ∉ Q → motive Q → motive (insert p Q) := by
          intro p Q hp_notmemQ hQ hsubPQ
          have hpP : p ∈ P := hsubPQ (Finset.mem_insert_self p Q)
          have hQsub : Q ⊆ P := by
            intro q hq
            exact hsubPQ (Finset.mem_insert_of_mem hq)
          rcases hQ hQsub with ⟨y, hyJ, hyavoid⟩
          by_cases hpy : w i + y ∈ p
          · -- We need to modify `y` by adding an element `y' ∈ J` that lies in every `q ∈ Q`
            -- but not in `p`.
            have hpI : p ∈ I.minimalPrimes := (hmemP p).1 hpP
            haveI : p.IsPrime := Ideal.minimalPrimes_isPrime hpI
            have hIp : I ≤ p := hpI.1.2
            have hJnot : ¬ J ≤ p := by
              intro hJle
              have hyP : y ∈ p := hJle hyJ
              have hwiP : w i ∈ p := by
                have hsub' : (w i + y) - y ∈ p := p.sub_mem hpy hyP
                have : (w i + y) - y = w i := add_sub_cancel_right (w i) y
                simpa [this] using hsub'
              -- Then all coordinates of `w` lie in `p`, contradicting unimodularity.
              have hall : ∀ j : s, w j ∈ p := by
                intro j
                by_cases hjS : j ∈ S
                · -- `w j ∈ I ≤ p`.
                  have hjI : w j ∈ I := by
                    refine Ideal.subset_span ?_
                    refine ⟨j, ?_⟩
                    simp [hjS]
                  exact hIp hjI
                · by_cases hji : j = i
                  · subst hji
                    exact hwiP
                  · -- Otherwise `j ∉ insert i S`, hence `w j ∈ J ≤ p`.
                    have hjJ : w j ∈ J := by
                      refine Ideal.subset_span ?_
                      refine ⟨j, ?_⟩
                      have : j ∉ insert i S := by
                        simp [hjS, hji]
                      simp [this]
                    exact hJle hjJ
              have hspan : Ideal.span (Set.range w) ≤ p := by
                refine Ideal.span_le.2 ?_
                rintro _ ⟨j, rfl⟩
                exact hall j
              have htop : (⊤ : Ideal A) ≤ p := by
                -- Use `span (range w) = ⊤` (unimodularity) without `simp`.
                exact le_trans (le_of_eq hw_unimod.symm) hspan
              exact (Ideal.IsPrime.ne_top (I := p) ‹p.IsPrime›) (top_le_iff.1 htop)
            rcases (Set.not_subset.1 hJnot) with ⟨z, hzJ, hznot⟩
            -- Build `t ∈ ⋂ q∈Q, q` with `t ∉ p` by multiplying elements from each `q`.
            classical
            have hsel : ∀ q ∈ Q, ∃ x : A, x ∈ q ∧ x ∉ p := by
              intro q hqQ
              have hqP : q ∈ P := hQsub hqQ
              have hqI : q ∈ I.minimalPrimes := (hmemP q).1 hqP
              have hq_ne_p : q ≠ p := by
                intro hqp
                subst hqp
                exact hp_notmemQ hqQ
              have hq_notle : ¬ q ≤ p := by
                intro hle
                have hp_le_q : p ≤ q := hpI.2 hqI.1 hle
                exact hq_ne_p (le_antisymm hle hp_le_q)
              rcases (Set.not_subset.1 hq_notle) with ⟨x, hxq, hxnp⟩
              exact ⟨x, hxq, hxnp⟩
            let x : Ideal A → A :=
              fun q => if h : q ∈ Q then Classical.choose (hsel q h) else 1
            have hxmem : ∀ q ∈ Q, x q ∈ q := by
              intro q hqQ
              have hs : Classical.choose (hsel q hqQ) ∈ q := (Classical.choose_spec (hsel q hqQ)).1
              simpa [x, hqQ] using hs
            have hxnot : ∀ q ∈ Q, x q ∉ p := by
              intro q hqQ
              have hs : Classical.choose (hsel q hqQ) ∉ p := (Classical.choose_spec (hsel q hqQ)).2
              simpa [x, hqQ] using hs
            let t0 : A := ∏ q ∈ Q, x q
            have htQ : ∀ q ∈ Q, t0 ∈ q := by
              intro q hqQ
              have hmul :
                  (∏ r ∈ Q.erase q, x r) * x q = ∏ r ∈ Q, x r :=
                Finset.prod_erase_mul (s := Q) (f := x) hqQ
              have hxq : x q ∈ q := hxmem q hqQ
              have : (∏ r ∈ Q.erase q, x r) * x q ∈ q :=
                Ideal.mul_mem_left q (∏ r ∈ Q.erase q, x r) hxq
              simpa [t0, hmul] using this
            have ht0np : t0 ∉ p := by
              intro ht0p
              have : ∃ q ∈ Q, x q ∈ p :=
                (Ideal.IsPrime.prod_mem_iff (p := p) (s := Q) (x := x)).1 ht0p
              rcases this with ⟨q, hqQ, hxqp⟩
              exact (hxnot q hqQ) hxqp
            let y' : A := t0 * z
            have hy'J : y' ∈ J := Ideal.mul_mem_left J t0 hzJ
            have hy'Q : ∀ q ∈ Q, y' ∈ q := by
              intro q hq
              have htq : t0 ∈ q := htQ q hq
              simpa [y', mul_comm] using Ideal.mul_mem_left q z htq
            have hy'not : y' ∉ p := by
              intro hy'p
              have : t0 ∈ p ∨ z ∈ p := (show p.IsPrime from ‹p.IsPrime›).mem_or_mem hy'p
              cases this with
              | inl ht0p => exact ht0np ht0p
              | inr hzp => exact hznot hzp
            let yNew : A := y + y'
            refine ⟨yNew, ?_, ?_⟩
            · -- `yNew ∈ J`
              exact J.add_mem hyJ hy'J
            · intro q hq
              rcases Finset.mem_insert.1 hq with hq | hq
              · subst q
                -- For `p`: since `w i + y ∈ p` but `y' ∉ p`.
                intro hpNew
                have : y' ∈ p := by
                  have hy'_eq : (w i + (y + y')) - (w i + y) = y' := by
                    calc
                      w i + (y + y') - (w i + y) =
                          (w i + y + y') - (w i + y) := by simp [add_assoc]
                      _ = y' := add_sub_cancel_left (w i + y) y'
                  have hsub' : (w i + (y + y')) - (w i + y) ∈ p := p.sub_mem hpNew hpy
                  exact hy'_eq ▸ hsub'
                exact hy'not this
              · -- For old primes `q ∈ Q`: since `w i + y ∉ q` and `y' ∈ q`.
                have hyq : w i + y ∉ q := hyavoid q hq
                have hy'q : y' ∈ q := hy'Q q hq
                intro hsum
                have : w i + y ∈ q := by
                  have : w i + y = (w i + (y + y')) - y' := by
                    simp [sub_eq_add_neg, add_assoc, add_left_comm, add_comm]
                  have hsub' : (w i + (y + y')) - y' ∈ q := q.sub_mem hsum hy'q
                  simpa [this] using hsub'
                exact hyq this
          · -- No modification needed; `y` already avoids `p`.
            refine ⟨y, hyJ, ?_⟩
            intro q hq
            rcases Finset.mem_insert.1 hq with hq | hq
            · subst hq
              exact hpy
            · exact hyavoid q hq
        -- Apply the induction with `Q = P`.
        have hmot : motive P := Finset.induction_on P h0 hstep
        simpa using hmot (subset_rfl)
      rcases havoidP with ⟨y, hyJ, hyavoidP⟩
      -- Convert the avoidance statement to the set `I.minimalPrimes`.
      have hyavoid : ∀ p ∈ I.minimalPrimes, w i + y ∉ p := by
        intro p hpI
        have hpP : p ∈ P := (hmemP p).2 hpI
        exact hyavoidP p hpP
      -- Express `y` as a linear combination of the generators of `J`, then realize the update by `GL`.
      have hy_mem : y ∈ J := hyJ
      rcases (Ideal.mem_span_range_iff_exists_fun).1 hy_mem with ⟨c, hc⟩
      let U : Finset s := Finset.univ.filter fun j : s => j ∉ insert i S
      have hiU : i ∉ U := by
        simp [U]
      have hy_sum :
          ∑ j ∈ U, c j * w j = y := by
        have hc0 :
            (∑ j : s, c j * (if j ∈ insert i S then (0 : A) else w j)) = y := by
          simpa [J] using hc
        have hc1 :
            (∑ j : s, if j ∉ insert i S then c j * w j else 0) = y := by
          have hterm :
              (∑ j : s, c j * (if j ∈ insert i S then (0 : A) else w j)) =
                ∑ j : s, if j ∉ insert i S then c j * w j else 0 := by
            refine Fintype.sum_congr _ _ ?_
            intro j
            by_cases hj : j ∈ insert i S
            · simp [hj]
            · simp [hj]
          exact hterm ▸ hc0
        have hc2 :
            (∑ j ∈ (Finset.univ : Finset s), if j ∉ insert i S then c j * w j else 0) = y := by
          simpa using hc1
        have hfilter :
            (∑ j ∈ (Finset.univ : Finset s), if j ∉ insert i S then c j * w j else 0) =
              ∑ j ∈ U, c j * w j := by
          simpa [U] using
            (Finset.sum_filter (s := (Finset.univ : Finset s)) (p := fun j : s => j ∉ insert i S)
                (f := fun j : s => c j * w j)).symm
        exact hfilter.symm.trans hc2
      let w1 : s → A := Function.update w i (w i + y)
      have hww1 : UnimodularVectorEquiv w w1 := by
        -- Realize the update using elementary transvections indexed by `U`.
        have hU :
            UnimodularVectorEquiv w
              (Function.update w i (w i + ∑ j ∈ U, c j * w j)) :=
          unimodularVectorEquiv_update_add_sum (A := A) (s := s) i U hiU c w
        simpa [w1, hy_sum] using hU
      have hvw1 : UnimodularVectorEquiv v w1 :=
        (unimodularVectorEquiv_equivalence (R := A) (s := s)).trans hvw hww1
      have hI_same : Iof S w1 = I := by
        have hw1_eq : ∀ j : s, j ∈ S → w1 j = w j := by
          intro j hj
          have hji : j ≠ i := by
            intro h
            subst h
            exact hi_notmem hj
          simp [w1, hji]
        have hfun :
            (fun j : s => if j ∈ S then w1 j else 0) =
              (fun j : s => if j ∈ S then w j else 0) := by
          funext j
          by_cases hj : j ∈ S
          · simp [hj, hw1_eq j hj]
          · simp [hj]
        simp [Iof, I, hfun]
      have hheight' : (S.card : ℕ∞) ≤ (Iof S w1).height := by
        simpa [hI_same] using hheight
      -- Height increase: adjoining the `i`-th coordinate raises the height by at least `1`.
      have hstep_height :
          (S.card : ℕ∞) + 1 ≤ (I ⊔ Ideal.span ({w1 i} : Set A)).height := by
        have : (S.card : ℕ∞) ≤ I.height := by
          -- `I` is the same as `Iof S w`, and `w1` does not show indices in `S`.
          simpa [hI_same] using hheight'
        have havo : ∀ p ∈ I.minimalPrimes, w1 i ∉ p := by
          intro p hp
          have : w1 i = w i + y := by
            simp [w1]
          simpa [this] using hyavoid p hp
        exact
          Ideal.height_add_one_le_of_forall_notMem_minimalPrimes (I := I) (a := w1 i)
            (k := (S.card : ℕ∞)) this havo
      -- The ideal generated by `insert i S` contains `I ⊔ (w1 i)`, so its height is at least the
      -- same.
      have hsup :
          (I ⊔ Ideal.span ({w1 i} : Set A)) ≤ Iof (insert i S) w1 := by
        refine sup_le ?_ ?_
        · -- `I ≤ I(insert i S)`
          refine (Ideal.span_le).2 ?_
          rintro _ ⟨j, rfl⟩
          by_cases hj : j ∈ S
          · -- generator is `w1 j`, and `j ∈ insert i S`
            have hj' : j ∈ insert i S := Finset.mem_insert_of_mem hj
            have hji : j ≠ i := by
              intro h
              subst h
              exact hi_notmem hj
            have hw1j : w1 j = w j := by
              simp [w1, hji]
            -- `w j` agrees with the generator `w1 j` because `j ≠ i`.
            exact Ideal.subset_span ⟨j, by simp [hj', hj, hw1j]⟩
          · -- generator is `0`
            simp [Iof, hj]
        · -- `span {w1 i} ≤ I(insert i S)`
          refine Ideal.span_le.2 ?_
          intro x hx
          -- `({w1 i} : Set A)` is a singleton set, so `x = w1 i`.
          subst hx
          exact Ideal.subset_span ⟨i, by simp [w1]⟩
      have hheight_insert :
          ((insert i S).card : ℕ∞) ≤ (Iof (insert i S) w1).height := by
        -- `card (insert i S) = card S + 1` because `i ∉ S`.
        -- Convert the height bound and use monotonicity.
        have hmono : (I ⊔ Ideal.span ({w1 i} : Set A)).height ≤ (Iof (insert i S) w1).height :=
          Ideal.height_mono hsup
        have hstep' : (S.card : ℕ∞) + 1 ≤ (Iof (insert i S) w1).height :=
          le_trans hstep_height hmono
        -- Rewrite `(S.card : ℕ∞) + 1` as `((insert i S).card : ℕ∞)`.
        -- `norm_cast` works here.
        have : ((insert i S).card : ℕ∞) = (S.card : ℕ∞) + 1 := by
          -- Cast the natural equality `card_insert_of_not_mem`.
          have hcardNat : (insert i S).card = S.card + 1 := by
            simpa using (Finset.card_insert_of_notMem (s := S) (a := i) hi_notmem)
          exact_mod_cast hcardNat
        simpa [this] using hstep'
      refine ⟨w1, hvw1, ?_⟩
      simpa [hI_same] using hheight_insert
  -- Apply the construction to `S = t`.
  rcases hbuild t (by intro x hx; exact hx) with ⟨v', hvv', htheight⟩
  -- Identify `I(t)` with the ideal generated by all coordinates except `o`.
  have hideal :
      Iof t v' = Ideal.span (Set.range fun j : s => if j = o then 0 else v' j) := by
    ext x
    simp [Iof, t]
  have htcard : (t.card : ℕ) + 1 = Fintype.card s := by
    simpa [t] using (Finset.card_erase_add_one (s := (Finset.univ : Finset s)) (a := o)
      (Finset.mem_univ o))
  have hdim_lt_t : ringKrullDim R < (↑(t.card) : WithBot ℕ∞) := by
    -- Rewrite `hs` as `dim R + 1 < t.card + 1` and cancel.
    have hs' : ringKrullDim R + 1 < (↑(t.card + 1) : WithBot ℕ∞) := by
      simpa [htcard] using hs
    have hs'' : ringKrullDim R + 1 < (↑(t.card) : WithBot ℕ∞) + 1 := by
      -- `↑(t.card + 1) = ↑t.card + 1`.
      have : (↑(t.card + 1) : WithBot ℕ∞) = (↑(t.card) : WithBot ℕ∞) + 1 := by
        simp [Nat.cast_add]
      simpa [this] using hs'
    exact lt_of_add_lt_add_right hs''
  have htheight' :
      (↑(t.card) : WithBot ℕ∞) ≤ (Iof t v').height := by
    -- Coerce `t.card ≤ height`.
    exact_mod_cast htheight
  have hfinal : ringKrullDim R < (Iof t v').height := lt_of_lt_of_le hdim_lt_t htheight'
  refine ⟨o, v', hvv', ?_⟩
  simpa [hideal] using hfinal

variable [IsPrincipalIdealRing R]

set_option maxHeartbeats 1000000 in
theorem exists_algEquiv_exists_equiv_exists_monic_finSuccEquiv (n : ℕ)
    (v : s → MvPolynomial (Fin (n + 1)) R) (hv : IsUnimodular v) :
    ∃ e : MvPolynomial (Fin (n + 1)) R ≃ₐ[R] MvPolynomial (Fin (n + 1)) R,
      ∃ w : s → MvPolynomial (Fin (n + 1)) R,
        UnimodularVectorEquiv (fun i : s => e (v i)) w ∧
          ∃ i : s, (MvPolynomial.finSuccEquiv R n (w i)).Monic := by
  classical
  cases hcard : Fintype.card s with
  | zero =>
    haveI : IsEmpty s := (Fintype.card_eq_zero_iff).1 hcard
    have hbot : (⊥ : Ideal (MvPolynomial (Fin (n + 1)) R)) = ⊤ := by
      simp [IsUnimodular, Set.range_eq_empty] at hv
    apply False.elim (bot_ne_top hbot)
  | succ m =>
    cases m with
    | zero =>
      -- `card s = 1`.
      have h1 : Fintype.card s = 1 := by simp [hcard]
      rcases (Fintype.card_eq_one_iff).1 h1 with ⟨o, ho⟩
      have hrange : Set.range v = {v o} := by
        ext x
        constructor
        · rintro ⟨i, rfl⟩
          simp [ho i]
        · intro hx
          rcases hx with rfl
          exact ⟨o, rfl⟩
      have hunit : IsUnit (v o) := by
        have : Ideal.span ({v o} : Set (MvPolynomial (Fin (n + 1)) R)) = ⊤ := by
          simpa [IsUnimodular, hrange] using hv
        exact (Ideal.span_singleton_eq_top).1 this
      rcases hunit with ⟨u, hu⟩
      let w : s → MvPolynomial (Fin (n + 1)) R := fun _ => 1
      let d : s → MvPolynomial (Fin (n + 1)) R := fun j => if j = o then (↑(u⁻¹) : _) else 1
      let D : Matrix s s (MvPolynomial (Fin (n + 1)) R) := Matrix.diagonal d
      have hdet : IsUnit (Matrix.det D) := by
        -- With `card s = 1`, `det (diagonal d) = d o = u⁻¹`.
        have : Matrix.det D = (↑(u⁻¹) : MvPolynomial (Fin (n + 1)) R) := by
          have ho' : ∀ j : s, j = o := ho
          simp [D, d, Matrix.det_diagonal, ho', Finset.prod_const, Finset.card_univ, h1]
        rw [this]
        exact Units.isUnit (u⁻¹)
      refine ⟨AlgEquiv.refl, w, ?_, ?_⟩
      · refine ⟨Matrix.GeneralLinearGroup.mk'' D hdet, ?_⟩
        funext j
        -- The only coordinate is scaled by `u⁻¹`, turning it into `1`.
        have hj : j = o := ho j
        subst hj
        have hvu : v j = (u : MvPolynomial (Fin (n + 1)) R) := by simpa using hu.symm
        simp [w, D, d, Matrix.mulVec_diagonal, hvu]
      · refine ⟨o, ?_⟩
        simp [w]
    | succ m =>
      cases m with
      | zero =>
        -- `card s = 2`.
        have h2 : Fintype.card s = 2 := by simp [hcard]
        let eσ : s ≃ Fin 2 := Fintype.equivFinOfCardEq h2
        let a : s := eσ.symm 0
        let b : s := eσ.symm 1
        have h1 :
            (1 : MvPolynomial (Fin (n + 1)) R) ∈ Ideal.span (Set.range v) := by
          unfold IsUnimodular at hv
          simp [hv]
        rcases (Ideal.mem_span_range_iff_exists_fun).1 h1 with ⟨c, hc⟩
        have hc2 : c a * v a + c b * v b = (1 : MvPolynomial (Fin (n + 1)) R) := by
          have hsum :
              (∑ i : s, c i * v i) =
                ∑ j : Fin 2, c (eσ.symm j) * v (eσ.symm j) := by
            simpa using
              (Fintype.sum_equiv (e := eσ.symm)
                    (f := fun j : Fin 2 => c (eσ.symm j) * v (eσ.symm j))
                    (g := fun i : s => c i * v i) (by intro j; simp)).symm
          have : ∑ j : Fin 2, c (eσ.symm j) * v (eσ.symm j) = (1 : MvPolynomial (Fin (n + 1)) R) := by
            simpa [hsum] using hc
          simpa [Fin.sum_univ_two, a, b] using this
        let w : s → MvPolynomial (Fin (n + 1)) R := fun i => if i = a then 1 else 0
        let MFin : Matrix (Fin 2) (Fin 2) (MvPolynomial (Fin (n + 1)) R) :=
          !![c a, c b; -v b, v a]
        let M : Matrix s s (MvPolynomial (Fin (n + 1)) R) := Matrix.reindex eσ.symm eσ.symm MFin
        have hdet : IsUnit (Matrix.det M) := by
          have hdet' : Matrix.det M = (1 : MvPolynomial (Fin (n + 1)) R) := by
            -- `det` is preserved under simultaneous reindexing.
            have hre : Matrix.det M = Matrix.det MFin := by
              simp [M]
            -- Compute the `2×2` determinant using the Bézout relation.
            have : Matrix.det MFin = (1 : MvPolynomial (Fin (n + 1)) R) := by
              -- Keep the multiplication order to match `hc2`.
              simp [MFin, Matrix.det_fin_two, hc2, sub_eq_add_neg]
            exact hre.trans this
          rw [hdet']
          exact (isUnit_one : IsUnit (1 : MvPolynomial (Fin (n + 1)) R))
        have hmul : (M.mulVec v) = w := by
          funext i
          -- Reduce to the `Fin 2` computation.
          have hentry :
              ∀ (x y : s),
                M x y = MFin (eσ x) (eσ y) := by
            intro x y
            simp [M]
          have hsum :
              (∑ j : s, M i j * v j) =
                ∑ j : Fin 2, MFin (eσ i) j * v (eσ.symm j) := by
            simpa [Matrix.mulVec, dotProduct, hentry] using
              (Fintype.sum_equiv (e := eσ.symm)
                    (f := fun j : Fin 2 => MFin (eσ i) j * v (eσ.symm j))
                    (g := fun j : s => MFin (eσ i) (eσ j) * v j) (by intro j; simp)).symm
          -- Now do the finite case analysis on `eσ i : Fin 2`.
          cases h : eσ i using Fin.cases with
          | zero =>
            -- `eσ i = 0`
            have : i = a := by
              have h' := congrArg eσ.symm h
              simp only [Equiv.symm_apply_apply, Fin.isValue] at h'
              exact h'
            subst this
            -- first row is the Bézout combination
            have : (∑ j : s, M a j * v j) = 1 := by
              calc _ = ∑ j : Fin 2, MFin (eσ a) j * v (eσ.symm j) := hsum
                _ = ∑ j : Fin 2, MFin 0 j * v (eσ.symm j) := by
                  simp only [h, Fin.isValue, Fin.sum_univ_two]
                _ = c a * v a + c b * v b := by
                  simp only [Fin.isValue, Matrix.of_apply, Matrix.cons_val', Matrix.cons_val_fin_one, Matrix.cons_val_zero, Fin.sum_univ_two,
                  Matrix.cons_val_one, MFin, a, b]
                _ = 1 := hc2
            simpa only [Matrix.mulVec, dotProduct, ↓reduceIte, w] using this
          | succ j =>
            -- `eσ i = 1`
            fin_cases j
            have : i = b := by
              have h' := congrArg eσ.symm h
              simp only [Equiv.symm_apply_apply] at h'
              exact h'
            subst this
            -- second row gives `-v b * v a + v a * v b = 0`.
            have : (∑ j : s, M b j * v j) = 0 := by
              calc _ = ∑ j : Fin 2, MFin (eσ b) j * v (eσ.symm j) := hsum
                _ = ∑ j : Fin 2, MFin 1 j * v (eσ.symm j) := by
                  simp only [h, Fin.zero_eta, Fin.isValue, Fin.succ_zero_eq_one, Fin.sum_univ_two]
                _ = (-v b) * v a + v a * v b := by
                  simp only [Fin.isValue, Matrix.of_apply, Matrix.cons_val',
                    Matrix.cons_val_fin_one, Matrix.cons_val_one, Fin.sum_univ_two,
                    Matrix.cons_val_zero, neg_mul, MFin, a, b]
                _ = 0 := by simp only [mul_comm, mul_neg, neg_add_cancel]
            have hb : b ≠ a := by
              intro hba
              have h' : (1 : Fin 2) = 0 := by
                simpa [a, b] using congrArg eσ hba
              exact (by decide : (1 : Fin 2) ≠ 0) h'
            simp [Matrix.mulVec, dotProduct, w, hb]
            exact this
        refine ⟨AlgEquiv.refl, w, ?_, ?_⟩
        · refine ⟨Matrix.GeneralLinearGroup.mk'' M hdet, ?_⟩
          simp [hmul]
        · refine ⟨a, ?_⟩
          simp [w]
      | succ m =>
        -- `card s ≥ 3`: use height preprocessing + Suslin's monic theorem + elementary updates.
        have hsNat : 2 < Fintype.card s := by
          -- `card s = (m+3)` in this branch.
          rw [hcard]
          have h0 : 0 < m + 1 := Nat.succ_pos m
          have h1 : 1 < m + 1 + 1 := Nat.succ_lt_succ h0
          have h2 : 2 < m + 1 + 1 + 1 := Nat.succ_lt_succ h1
          exact h2
        have hs :
            ringKrullDim R + 1 < (↑(Fintype.card s) : WithBot ℕ∞) := by
          -- In a PID, `dim R ≤ 1`, so `dim R + 1 ≤ 2`, and `2 < card s` in this branch.
          have hle' : ringKrullDim R ≤ (↑(1 : ℕ) : WithBot ℕ∞) := by
            simpa [Ring.krullDimLE_iff] using
              (show Ring.KrullDimLE 1 R from inferInstance)
          have hle : ringKrullDim R ≤ (1 : WithBot ℕ∞) := by simpa using hle'
          have hle2 : ringKrullDim R + 1 ≤ (2 : WithBot ℕ∞) := by
            have : ringKrullDim R + 1 ≤ (1 : WithBot ℕ∞) + 1 := by
              -- `add_le_add_right` sometimes returns `1 + ringKrullDim R ≤ 1 + 1`; commute if needed.
              simpa [add_comm] using (add_le_add_right hle (1 : WithBot ℕ∞))
            simpa [one_add_one_eq_two] using this
          have hsCard : (2 : WithBot ℕ∞) < (↑(Fintype.card s) : WithBot ℕ∞) := by
            exact_mod_cast hsNat
          exact lt_of_le_of_lt hle2 hsCard
        rcases exists_equiv_exists_index_height_gt_krullDim (R := R) (s := s) n v hv hs with
          ⟨o, v', hvv', hheight⟩
        let I : Ideal (MvPolynomial (Fin (n + 1)) R) :=
          Ideal.span (Set.range (fun i : s => if i = o then 0 else v' i))
        have hr : ringKrullDim R < (⊤ : WithBot ℕ∞) := by
          -- In a PID, `dim R ≤ 1`, hence `dim R < ∞`.
          have hle : ringKrullDim R ≤ (↑(1 : ℕ) : WithBot ℕ∞) := by
            simpa [Ring.krullDimLE_iff] using
              (show Ring.KrullDimLE 1 R from inferInstance)
          have h1lt : (↑(1 : ℕ) : WithBot ℕ∞) < ⊤ := by
            refine (lt_top_iff_ne_top).2 ?_
            intro h
            have h' : ((1 : ℕ) : ℕ∞) = (⊤ : ℕ∞) := by
              have : (↑((1 : ℕ) : ℕ∞) : WithBot ℕ∞) = (↑(⊤ : ℕ∞) : WithBot ℕ∞) := by
                simpa using h
              exact WithBot.coe_eq_coe.mp this
            exact (WithTop.coe_ne_top (a := (1 : ℕ))) h'
          exact lt_of_le_of_lt hle h1lt
        rcases suslin_monic_polynomial_theorem (R := R) hr n I (by simpa [I] using hheight) with
          ⟨α, f, hfI, hmonicf⟩
        -- Express `f` as a linear combination of the generators of `I`.
        rcases (Ideal.mem_span_range_iff_exists_fun).1 hfI with ⟨c, hc⟩
        -- Work in `A[X]` via `finSuccEquiv`.
        let A := MvPolynomial (Fin n) R
        letI instA : CommRing A := by
          dsimp [A]
          infer_instance
        -- Keep the `CommSemiring` structure on `A` definitional to the one coming from `CommRing`,
        -- so that all `Polynomial A` occurrences use the same instance parameters.
        letI : CommSemiring A := instA.toCommSemiring
        let φ : MvPolynomial (Fin (n + 1)) R ≃ₐ[R] Polynomial A := MvPolynomial.finSuccEquiv R n
        let φr : MvPolynomial (Fin (n + 1)) R ≃+* Polynomial A := φ.toRingEquiv
        let u : s → MvPolynomial (Fin (n + 1)) R := fun i => α (v' i)
        let uPoly : s → Polynomial A := fun i => φ (u i)
        let fPoly : Polynomial A := φ (α f)
        have hmonic_fPoly : fPoly.Monic := by
          simpa [fPoly, φ] using hmonicf
        have hcf :
            (∑ i : s, φ (α (c i)) * (if i = o then 0 else uPoly i)) = fPoly := by
          -- Push the relation `hc` through `α` and `φ`, and simplify term-by-term.
          have hc' : (∑ i : s, c i * (if i = o then 0 else v' i)) = f := hc
          have hmap : φ (α (∑ i : s, c i * (if i = o then 0 else v' i))) = φ (α f) := by
            simpa [hc'] using congrArg (fun x => φ (α x)) hc'
          -- Rewrite the left side using `map_sum`, then simplify each summand by cases on `i = o`.
          have hsum :
              (∑ i : s, φ (α (c i * (if i = o then 0 else v' i)))) = φ (α f) := by
            -- `φ ∘ α` is additive.
            simpa [map_sum] using hmap
          -- Replace each mapped product with the desired product in `A[X]`.
          have hterm :
              (∑ i : s, φ (α (c i * (if i = o then 0 else v' i)))) =
                ∑ i : s, φ (α (c i)) * (if i = o then 0 else uPoly i) := by
            refine Fintype.sum_congr _ _ ?_
            intro i
            by_cases hi : i = o
            · subst hi
              simp [uPoly]
            · simp [uPoly, u, hi, map_mul]
          -- Conclude.
          have hcf' := hterm.symm.trans hsum
          dsimp [fPoly]
          exact hcf'
        -- Add `X^N * fPoly` to the `o`-th coordinate using elementary updates.
        let N : ℕ := (uPoly o).natDegree + 1
        let t : Finset s := Finset.univ.erase o
        let wPolyOf (t : Finset s) : s → Polynomial A :=
          Function.update uPoly o
            (uPoly o + ∑ i ∈ t, (Polynomial.X ^ N * φ (α (c i))) * uPoly i)
        let wPoly : s → Polynomial A := wPolyOf t
        have huwPoly : UnimodularVectorEquiv uPoly wPoly := by
          classical
          -- Induct over `t` and apply `unimodularVectorEquiv_update_add` at each step.
          have hwPolyOf :
              ∀ t : Finset s, o ∉ t → UnimodularVectorEquiv uPoly (wPolyOf t) := by
            intro t
            refine Finset.induction_on t ?_ ?_
            · intro _
              -- empty set
              have hw0 : wPolyOf (∅ : Finset s) = uPoly := by
                funext j
                by_cases hj : j = o
                · subst j
                  simp [wPolyOf]
                · simp [wPolyOf, hj]
              have : UnimodularVectorEquiv uPoly uPoly :=
                (unimodularVectorEquiv_equivalence (R := Polynomial A) (s := s)).1 uPoly
              simpa [hw0] using this
            · intro i t hi_notmem ih ht_insert
              have ht : o ∉ t := by
                intro ho
                exact ht_insert (Finset.mem_insert_of_mem ho)
              have hio : i ≠ o := by
                intro hio
                have : o ∈ insert i t := by
                  subst i
                  exact Finset.mem_insert_self o t
                exact ht_insert this
              have ih' : UnimodularVectorEquiv uPoly (wPolyOf t) := ih ht
              -- Add the new term at coordinate `o`.
              have hadd :
                  UnimodularVectorEquiv (wPolyOf t)
                    (Function.update (wPolyOf t) o
                      ((wPolyOf t) o + (Polynomial.X ^ N * φ (α (c i))) * (wPolyOf t) i)) := by
                simpa using
                  unimodularVectorEquiv_update_add (R := A) (s := s) o i (Ne.symm hio)
                    (Polynomial.X ^ N * φ (α (c i))) (wPolyOf t)
              have hwPoly_step :
                  Function.update (wPolyOf t) o
                      ((wPolyOf t) o + (Polynomial.X ^ N * φ (α (c i))) * (wPolyOf t) i) =
                    wPolyOf (insert i t) := by
                funext j
                by_cases hj : j = o
                · subst j
                  have hi_t : (wPolyOf t) i = uPoly i := by
                    simp [wPolyOf, hio]
                  have ho_t :
                      (wPolyOf t) o =
                        uPoly o +
                          ∑ j ∈ t, (Polynomial.X ^ N * φ (α (c j))) * uPoly j := by
                    simp [wPolyOf]
                  have ho_it :
                      (wPolyOf (insert i t)) o =
                        uPoly o +
                          ∑ j ∈ insert i t, (Polynomial.X ^ N * φ (α (c j))) * uPoly j := by
                    simp [wPolyOf]
                  -- Compare the updated `o`-th coordinate.
                  have :
                      (wPolyOf t) o +
                          (Polynomial.X ^ N * φ (α (c i))) * (wPolyOf t) i =
                        uPoly o +
                          ∑ j ∈ insert i t, (Polynomial.X ^ N * φ (α (c j))) * uPoly j := by
                    -- Rewrite using `ho_t`, `hi_t`, and `Finset.sum_insert`.
                    -- `wPolyOf t` differs from `uPoly` only at `o`.
                    calc
                      (wPolyOf t) o +
                          (Polynomial.X ^ N * φ (α (c i))) * (wPolyOf t) i =
                          (uPoly o +
                              ∑ j ∈ t, (Polynomial.X ^ N * φ (α (c j))) * uPoly j) +
                            (Polynomial.X ^ N * φ (α (c i))) * uPoly i := by
                              simp [ho_t, hi_t]
                      _ =
                          uPoly o +
                            ((Polynomial.X ^ N * φ (α (c i))) * uPoly i +
                              ∑ j ∈ t, (Polynomial.X ^ N * φ (α (c j))) * uPoly j) := by
                              ac_rfl
                      _ =
                          uPoly o +
                            ∑ j ∈ insert i t, (Polynomial.X ^ N * φ (α (c j))) * uPoly j := by
                              simp [Finset.sum_insert, hi_notmem]
                  simpa [Function.update_self, ho_it] using this
                · -- `j ≠ o`: both sides are unshowd and equal to `uPoly j`.
                  have hj' : j ≠ o := hj
                  have ht : (wPolyOf t) j = uPoly j := by
                    simp [wPolyOf, hj']
                  have hit : (wPolyOf (insert i t)) j = uPoly j := by
                    simp [wPolyOf, hj']
                  -- The update at `o` does not affect `j`.
                  simp [Function.update_of_ne hj', ht, hit]
              exact
                unimodularVectorEquiv_equivalence.trans ih'
                  (by simpa [hwPoly_step] using hadd)
          have ht0 : o ∉ t := by
            -- `t = univ.erase o`.
            simp [t]
          simpa [wPoly] using hwPolyOf t ht0
        -- Map back to `MvPolynomial` and build `w`.
        let w : s → MvPolynomial (Fin (n + 1)) R := fun i => φ.symm (wPoly i)
        have huw : UnimodularVectorEquiv u w := by
          have := unimodularVectorEquiv_map_ringEquiv (s := s) (φr.symm) uPoly wPoly huwPoly
          have hcompu : (fun i : s => φr.symm (uPoly i)) = u := by
            funext i
            simpa [uPoly, u, φr] using (φr.symm_apply_apply (u i))
          have hcompw : (fun i : s => φr.symm (wPoly i)) = w := by
            funext i
            dsimp [w, φr]
            rfl
          simpa [hcompu, hcompw] using this
        have hαvv' : UnimodularVectorEquiv (fun i : s => α (v i)) u :=
          unimodularVectorEquiv_map_ringEquiv (s := s) α.toRingEquiv v v' hvv'
        -- Assemble the final equivalence.
        have hαvw : UnimodularVectorEquiv (fun i : s => α (v i)) w :=
          unimodularVectorEquiv_equivalence.trans hαvv' huw
        -- Show the `o`-th coordinate is monic.
        have hmonic_wPoly : (MvPolynomial.finSuccEquiv R n (w o)).Monic := by
          -- First identify `finSuccEquiv` with the constructed polynomial.
          have hw : MvPolynomial.finSuccEquiv R n (w o) = wPoly o := by
            show φ (φ.symm (wPoly o)) = wPoly o
            simp
          -- Rewrite `wPoly o` as `uPoly o + X^N * fPoly`, using `hcf`.
          have hsum_cf :
              (∑ i : s, φ (α (c i)) * (if i = o then 0 else uPoly i)) =
                ∑ i ∈ t, φ (α (c i)) * uPoly i := by
            classical
            -- Drop the `i = o` term, which is zero, using `Finset.sum_erase_add` on `univ`.
            let h : s → Polynomial A := fun i => φ (α (c i)) * (if i = o then 0 else uPoly i)
            let g : s → Polynomial A := fun i => φ (α (c i)) * uPoly i
            have ho : o ∈ (Finset.univ : Finset s) := by simp
            have h_erase :
                (∑ i ∈ (Finset.univ.erase o : Finset s), h i) =
                  ∑ i ∈ (Finset.univ.erase o : Finset s), g i := by
              refine Finset.sum_congr rfl ?_
              intro i hi
              have : i ≠ o := by
                simpa [Finset.mem_erase] using hi
              simp [h, g, this]
            have hs :
                (∑ i ∈ (Finset.univ.erase o : Finset s), h i) + h o =
                  ∑ i ∈ (Finset.univ : Finset s), h i :=
              Finset.sum_erase_add (Finset.univ : Finset s) h ho
            have ho0 : h o = 0 := by simp [h]
            have hs' :
                (∑ i ∈ (Finset.univ.erase o : Finset s), h i) =
                  ∑ i ∈ (Finset.univ : Finset s), h i := by
              simp [ho0]
            have :
                (∑ i ∈ (Finset.univ.erase o : Finset s), g i) =
                  ∑ i ∈ (Finset.univ : Finset s), h i := by
              simpa [h_erase] using hs'
            -- Rewrite sums over `univ` back to `Fintype`-sums and unfold `h`, `g`, and `t`.
            simpa [h, g, t] using this.symm
          have hwPoly_o :
              wPoly o = uPoly o + Polynomial.X ^ N * fPoly := by
            classical
            -- First compute the `o`-th coordinate of `wPoly`.
            have hwPoly_o' :
                wPoly o =
                  uPoly o + ∑ i ∈ t, (Polynomial.X ^ N * φ (α (c i))) * uPoly i := by
              simp [wPoly, wPolyOf]
            -- Then rewrite the sum using `hcf` and `hsum_cf`.
            have hsum_t : (∑ i ∈ t, φ (α (c i)) * uPoly i) = fPoly := by
              calc
                (∑ i ∈ t, φ (α (c i)) * uPoly i) =
                    ∑ i : s, φ (α (c i)) * (if i = o then 0 else uPoly i) := by
                      simpa using hsum_cf.symm
                _ = fPoly := hcf
            have hsum_X :
                (∑ i ∈ t, (Polynomial.X ^ N * φ (α (c i))) * uPoly i) =
                  Polynomial.X ^ N * fPoly := by
              -- Factor out `X^N` and use `hsum_t`.
              calc
                (∑ i ∈ t, (Polynomial.X ^ N * φ (α (c i))) * uPoly i) =
                    ∑ i ∈ t, Polynomial.X ^ N * (φ (α (c i)) * uPoly i) := by
                      refine Finset.sum_congr rfl ?_
                      intro i hi
                      simp [mul_assoc]
                _ =
                    Polynomial.X ^ N * ∑ i ∈ t, φ (α (c i)) * uPoly i := by
                      simp [Finset.mul_sum]
                _ = Polynomial.X ^ N * fPoly := by
                      simp [hsum_t]
            -- Conclude.
            calc
              wPoly o =
                  uPoly o + ∑ i ∈ t, (Polynomial.X ^ N * φ (α (c i))) * uPoly i := hwPoly_o'
              _ = uPoly o + Polynomial.X ^ N * fPoly := by
                  simp [hsum_X]
          -- Finally, use `Monic.add_of_right` with a degree inequality.
          have hdeg :
              (uPoly o).degree < (Polynomial.X ^ N * fPoly).degree := by
            -- `degree (uPoly o) ≤ natDegree (uPoly o) < N ≤ degree (X^N * fPoly)`.
            have hltN : (uPoly o).degree < (N : WithBot ℕ) := by
              have : (uPoly o).degree ≤ (uPoly o).natDegree := Polynomial.degree_le_natDegree
              have : (uPoly o).degree < (uPoly o).natDegree + 1 := lt_of_le_of_lt this (by
                -- coe inequality
                exact WithBot.coe_lt_coe.2 (Nat.lt_succ_self _))
              have hN : (N : WithBot ℕ) = (uPoly o).natDegree + 1 := by
                simp [N, Nat.cast_add, Nat.cast_one]
              -- Rewrite the goal using the definition of `N`.
              rw [hN]
              exact this
            have hN_le :
                (N : WithBot ℕ) ≤ (Polynomial.X ^ N * fPoly).degree := by
              -- `degree (X^N * fPoly) = degree fPoly + N` and `0 ≤ degree fPoly`.
              have hdeg_Xf : (Polynomial.X ^ N * fPoly).degree = fPoly.degree + N := by
                simp [mul_comm]
              -- `N = 0 + N ≤ degree fPoly + N`.
              have h0 : (0 : WithBot ℕ) ≤ fPoly.degree := by
                -- `fPoly` is nonzero (monic), hence degree ≥ 0.
                have hf0 : fPoly ≠ 0 := hmonic_fPoly.ne_zero
                have : (0 : WithBot ℕ) ≤ (fPoly.natDegree : WithBot ℕ) :=
                  (WithBot.coe_le_coe).2 (Nat.zero_le _)
                simp [Polynomial.degree_eq_natDegree hf0]
              have hN_le' : (N : WithBot ℕ) ≤ fPoly.degree + N := by
                simpa using (add_le_add_left h0 (N : WithBot ℕ))
              -- Conclude by rewriting `degree (X^N * fPoly)`.
              simpa [hdeg_Xf] using hN_le'
            exact lt_of_lt_of_le hltN hN_le
          have hmonic_Xf : (Polynomial.X ^ N * fPoly).Monic := (Polynomial.monic_X_pow N).mul hmonic_fPoly
          -- Conclude.
          have : (wPoly o).Monic := by
            -- `wPoly o = uPoly o + X^N * fPoly`
            simpa [hwPoly_o, add_comm, add_left_comm, add_assoc] using (Polynomial.Monic.add_of_right hmonic_Xf hdeg)
          simpa [hw] using this
        refine ⟨α, w, hαvw, ⟨o, hmonic_wPoly⟩⟩

variable {k : Type*} [CommRing k] [IsDomain k] [IsPrincipalIdealRing k]
variable {s : Type*} [Fintype s] [DecidableEq s]

theorem thm12 (o : s) {σ : Type*} [Fintype σ] [DecidableEq σ] (v : s → MvPolynomial σ k)
    (hv : IsUnimodular v) : UnimodularVectorEquiv v (fun i => if i = o then 1 else 0) := by
  classical
  let n : ℕ := Fintype.card σ
  let eσ : σ ≃ Fin n := Fintype.equivFin σ
  let ρ : MvPolynomial σ k ≃ₐ[k] MvPolynomial (Fin n) k := MvPolynomial.renameEquiv k eσ
  let v' : s → MvPolynomial (Fin n) k := fun i => ρ (v i)
  have hv' : IsUnimodular v' := isUnimodular_map_ringEquiv ρ.toRingEquiv v hv

  -- Fin-indexed (induction-on-variables) form.
  have hfin :
      ∀ n : ℕ,
        ∀ v : s → MvPolynomial (Fin n) k,
          IsUnimodular v → UnimodularVectorEquiv v (fun i : s => if i = o then 1 else 0) := by
    intro n
    induction n with
    | zero =>
      intro v hv
      let e : MvPolynomial (Fin 0) k ≃+* k := MvPolynomial.isEmptyRingEquiv k (Fin 0)
      have hv' : IsUnimodular fun i => e (v i) := isUnimodular_map_ringEquiv e v hv
      have hstd : IsUnimodular fun i : s => if i = o then (1 : k) else 0 := by
        unfold IsUnimodular
        refine
          Ideal.eq_top_of_isUnit_mem
            (I := Ideal.span (Set.range fun i : s => if i = o then (1 : k) else 0)) (x := (1 : k))
            ?_ isUnit_one
        exact Ideal.subset_span ⟨o, by simp⟩
      have h' :
          UnimodularVectorEquiv (fun i => e (v i)) (fun i : s => if i = o then (1 : k) else 0) := by
        simpa using unimodularVectorEquiv_of_pid (R := k) (s := s) hv' hstd
      have h'' :
          UnimodularVectorEquiv v (fun i : s => if i = o then (1 : MvPolynomial (Fin 0) k) else 0) := by
        have :=
          unimodularVectorEquiv_map_ringEquiv e.symm (fun i => e (v i))
            (fun i : s => if i = o then (1 : k) else 0) h'
        simpa using this
      simpa using h''
    | succ n ih =>
      intro v hv
      let A := MvPolynomial (Fin n) k
      let φ : MvPolynomial (Fin (n + 1)) k ≃ₐ[k] Polynomial A := MvPolynomial.finSuccEquiv k n
      let φr : MvPolynomial (Fin (n + 1)) k ≃+* Polynomial A := φ.toRingEquiv

      rcases
          exists_algEquiv_exists_equiv_exists_monic_finSuccEquiv (R := k) (s := s) n v hv with
        ⟨e, w, hvw⟩
      rcases hvw with ⟨hvw, hmonic⟩
      have hv' : IsUnimodular fun i : s => e (v i) := isUnimodular_map_ringEquiv e.toRingEquiv v hv
      have hw : IsUnimodular w :=
        (isUnimodular_iff_of_unimodularVectorEquiv_ring (s := s) (A := MvPolynomial (Fin (n + 1)) k)
              hvw).1
          hv'

      -- Work in `A[X]` via `φ`.
      let wpoly : s → Polynomial A := fun j => φr (w j)
      have hwpoly : IsUnimodular wpoly := by
        simpa [wpoly] using isUnimodular_map_ringEquiv φr w hw
      have hmonic' : ∃ j : s, (wpoly j).Monic := by
        rcases hmonic with ⟨i, hi⟩
        refine ⟨i, ?_⟩
        simpa [wpoly, φr, φ] using hi

      have hcor : UnimodularVectorEquiv wpoly (fun j => Polynomial.C ((wpoly j).eval 0)) :=
        cor11 (R := A) (s := s) wpoly hwpoly hmonic'

      let ev0 : Polynomial A →+* A := Polynomial.evalRingHom (R := A) 0
      let v0 : s → A := fun j => ev0 (wpoly j)
      have hv0 : IsUnimodular v0 := isUnimodular_map_ringHom ev0 wpoly hwpoly
      have hih : UnimodularVectorEquiv v0 (fun j : s => if j = o then (1 : A) else 0) := ih v0 hv0
      have hmap :
          UnimodularVectorEquiv (fun j => Polynomial.C (v0 j))
            (fun j : s => if j = o then (1 : Polynomial A) else 0) := by
        have := unimodularVectorEquiv_map (s := s) (Polynomial.C : A →+* Polynomial A) hih
        simpa [v0] using this

      have hwstdPoly :
          UnimodularVectorEquiv wpoly (fun j : s => if j = o then (1 : Polynomial A) else 0) := by
        have hcor0 : UnimodularVectorEquiv wpoly (fun j => Polynomial.C (v0 j)) := by
          simpa [v0, ev0] using hcor
        exact unimodularVectorEquiv_equivalence.trans hcor0 hmap

      have hwstd :
          UnimodularVectorEquiv w (fun j : s => if j = o then (1 : MvPolynomial (Fin (n + 1)) k) else 0) := by
        have :=
          unimodularVectorEquiv_map_ringEquiv φr.symm wpoly
            (fun j : s => if j = o then (1 : Polynomial A) else 0) hwstdPoly
        have hcomp : (fun j => φr.symm (wpoly j)) = w := by
          funext j
          simp [wpoly]
        have hstdcomp :
            (fun j : s => φr.symm (if j = o then (1 : Polynomial A) else 0)) =
              fun j : s => if j = o then (1 : MvPolynomial (Fin (n + 1)) k) else 0 := by
          funext j
          by_cases hj : j = o <;> simp [hj]
        simpa [hcomp, hstdcomp] using this

      -- Map back along `e.symm`.
      have he' :
          UnimodularVectorEquiv (fun j : s => e (v j))
            (fun j : s => if j = o then (1 : MvPolynomial (Fin (n + 1)) k) else 0) :=
        unimodularVectorEquiv_equivalence.trans hvw hwstd
      let er : MvPolynomial (Fin (n + 1)) k ≃+* MvPolynomial (Fin (n + 1)) k := e.toRingEquiv
      have :=
        unimodularVectorEquiv_map_ringEquiv er.symm (fun j => er (v j))
          (fun j : s => if j = o then (1 : MvPolynomial (Fin (n + 1)) k) else 0) (by
            simpa [er] using he')
      have hcomp : (fun j => er.symm (er (v j))) = v := by
        funext j
        simpa [er] using er.symm_apply_apply (v j)
      have hstdcomp :
          (fun j : s =>
              er.symm (if j = o then (1 : MvPolynomial (Fin (n + 1)) k) else 0)) =
            fun j : s => if j = o then (1 : MvPolynomial (Fin (n + 1)) k) else 0 := by
        funext j
        by_cases hj : j = o <;> simp [hj, er]
      simpa [hcomp, hstdcomp] using this

  have h' : UnimodularVectorEquiv v' (fun i : s => if i = o then 1 else 0) := hfin n v' hv'
  have :=
    unimodularVectorEquiv_map_ringEquiv ρ.symm.toRingEquiv v'
      (fun i : s => if i = o then 1 else 0) h'
  simpa [v', ρ] using this

end thm12_pid
